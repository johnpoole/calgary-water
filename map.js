import { RiskConsequenceModel } from "./risk_consequence.js";

const container = document.getElementById("map");
const statusEl = document.getElementById("status");
const tooltipEl = document.getElementById("tooltip");
const inspectorEl = document.getElementById("inspector");
const inspectorPreEl = document.getElementById("inspectorPre");
const inspectorCloseEl = document.getElementById("inspectorClose");
const legendOverlayEl = document.getElementById("legendOverlay");
const legendOverlayKeyTitleEl = document.getElementById("legendOverlayKeyTitle");
const legendOverlayKeyEl = document.getElementById("legendOverlayKey");
const legendDiameterEl = document.getElementById("legendDiameter");
const legendAgeEl = document.getElementById("legendAge");
const legendMaterialEl = document.getElementById("legendMaterial");
const legendBasemapEl = document.getElementById("legendBasemap");
const tilesEl = document.getElementById("tiles");
const legendEl = document.getElementById("legend");
const legendToggleEl = document.getElementById("legendToggle");
const legendBodyEl = document.getElementById("legendBody");
const helpToggleEl = document.getElementById("helpToggle");
const helpPanelEl = document.getElementById("helpPanel");
const helpCloseEl = document.getElementById("helpClose");

const geojsonUrl = "./data/Public_Water_Main_20251231.geojson";
const materialLabelsUrl = "./material_labels.json";
const breakDensityUrl = "./docs/break_density_by_p_zone.json";
const roadProximityUrl = "./docs/road_proximity_by_main.json";
const roadsUrl = "./data/Major_Road_Network_20251231.geojson";

// Loaded from docs/break_density_by_p_zone.json (generated by tools/break_density_by_p_zone.py)
let breakDensityByZone = new Map(); // p_zone -> breaks_per_km
let breakDensityScale = null; // d3.scaleQuantile returning 1..4
let breakDensityLegend = null; // { labels: string[], palette: string[], quantiles: number[] }

// Loaded from docs/road_proximity_by_main.json (generated by tools/major_roads_over_mains.py)
let roadExposureByGlobalId = new Map();
// globalid -> { functionalClass: string, upliftLof: number, minDistM: number|null, sourceCtpClass: string|null }
let roadExposureBufferM = null;

// Loaded from data/Major_Road_Network_20251231.geojson
let roadsGeojson = null;

const ROAD_AFFECTED_MATERIALS = new Set(["CI", "AC", "PCI", "PCCP", "CON"]);
const OLD_PVC_AGE_YEARS = 40;

// Tailwind-like blues (already used elsewhere in the project via hex codes).
const BREAK_DENSITY_PALETTE = ["#dbeafe", "#93c5fd", "#3b82f6", "#1d4ed8"];

function setLegendCollapsed(isCollapsed) {
  if (!legendEl || !legendToggleEl) return;
  legendEl.classList.toggle("is-collapsed", !!isCollapsed);
  legendToggleEl.setAttribute("aria-expanded", isCollapsed ? "false" : "true");
  legendToggleEl.textContent = isCollapsed ? "Show" : "Hide";
  if (legendBodyEl) legendBodyEl.setAttribute("aria-hidden", isCollapsed ? "true" : "false");
}

function initLegendToggle() {
  if (!legendEl || !legendToggleEl) return;

  const isSmall = window.matchMedia?.("(max-width: 640px)")?.matches ?? false;
  // On mobile: start collapsed. On desktop: start expanded.
  setLegendCollapsed(!!isSmall);

  legendToggleEl.addEventListener("click", () => {
    const isCollapsed =
      legendToggleEl.getAttribute("aria-expanded") === "false" ||
      legendEl.classList.contains("is-collapsed");
    setLegendCollapsed(!isCollapsed);
  });
}

function initHelpPanel() {
  if (!helpToggleEl || !helpPanelEl) return;

  function setOpen(open) {
    helpPanelEl.hidden = !open;
    helpToggleEl.setAttribute("aria-expanded", open ? "true" : "false");
  }

  // Start closed.
  setOpen(false);

  helpToggleEl.addEventListener("click", () => {
    setOpen(!!helpPanelEl.hidden);
  });

  helpCloseEl?.addEventListener("click", () => setOpen(false));

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") setOpen(false);
  });
}

function initInspector() {
  if (!inspectorEl) return;

  function setOpen(open) {
    inspectorEl.hidden = !open;
  }

  setOpen(false);

  inspectorCloseEl?.addEventListener("click", () => setOpen(false));
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") setOpen(false);
  });
}

// URL state (shareable view): stores zoom/pan + current filters in the query string.
// Example:
//   ?k=2.1&x=-120&y=85&bm=1&dia=%E2%89%A4150,300&age=%3C20,20%E2%80%9350&mat=PVC,Other
const urlState = {
  initialized: false,
  transform: d3.zoomIdentity,
  _pending: false,
};

function parseCsvParam(params, key) {
  const raw = params.get(key);
  if (raw == null) return null;
  const trimmed = raw.trim();
  if (!trimmed) return [];
  return trimmed
    .split(",")
    .map((s) => s.trim())
    .filter((s) => s.length > 0);
}

function readUrlStateIntoFilterState() {
  const params = new URLSearchParams(window.location.search);

  // Zoom transform
  const k = Number(params.get("k"));
  const x = Number(params.get("x"));
  const y = Number(params.get("y"));
  if (Number.isFinite(k) && k > 0 && Number.isFinite(x) && Number.isFinite(y)) {
    urlState.transform = d3.zoomIdentity.translate(x, y).scale(k);
  }

  // Basemap
  const bm = params.get("bm");
  if (bm != null) {
    filterState.basemapEnabled = bm === "1" || bm.toLowerCase() === "true";
  }

  // Roads layer
  const rd = params.get("rd");
  if (rd != null) {
    filterState.roadsEnabled = rd === "1" || rd.toLowerCase() === "true";
  }

  // Overlay
  const ov = (params.get("ov") ?? "").toString().trim().toLowerCase();
  if (ov === "risk" || ov === "consequence" || ov === "breaks" || ov === "roads" || ov === "none") {
    filterState.overlay = ov;
  }

  // Filters
  const dia = parseCsvParam(params, "dia");
  if (dia != null) {
    filterState.diameterBins = new Set(dia);
  }

  const age = parseCsvParam(params, "age");
  if (age != null) {
    filterState.ageBins = new Set(age);
  }

  const mat = parseCsvParam(params, "mat");
  if (mat != null) {
    filterState.materials = new Set(mat);
  }
}

function writeUrlState(transform) {
  const params = new URLSearchParams(window.location.search);

  // Keep params stable (so sharing URLs is predictable).
  const k = Number(transform?.k);
  const x = Number(transform?.x);
  const y = Number(transform?.y);
  if (Number.isFinite(k) && Number.isFinite(x) && Number.isFinite(y)) {
    params.set("k", k.toFixed(4));
    params.set("x", x.toFixed(2));
    params.set("y", y.toFixed(2));
  } else {
    params.delete("k");
    params.delete("x");
    params.delete("y");
  }

  params.set("bm", filterState.basemapEnabled ? "1" : "0");
  params.set("rd", filterState.roadsEnabled ? "1" : "0");
  params.set("ov", filterState.overlay ?? "none");
  params.set("dia", [...filterState.diameterBins].join(","));
  params.set("age", [...filterState.ageBins].join(","));
  params.set("mat", [...filterState.materials].join(","));

  const next = `${window.location.pathname}?${params.toString()}${window.location.hash}`;
  const current = `${window.location.pathname}${window.location.search}${window.location.hash}`;
  if (next !== current) {
    history.replaceState(null, "", next);
  }
}

function scheduleUrlWrite(transform) {
  urlState.transform = transform;
  if (urlState._pending) return;
  urlState._pending = true;
  window.requestAnimationFrame(() => {
    urlState._pending = false;
    writeUrlState(urlState.transform);
  });
}

// Online basemap tiles (OpenStreetMap). For production usage, use an approved tile provider.
const TILE_URL = "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
const TILE_MAX_Z = 19;

function clamp(n, lo, hi) {
  return Math.max(lo, Math.min(hi, n));
}

function lonToTileX(lon, z) {
  const n = 2 ** z;
  return Math.floor(((lon + 180) / 360) * n);
}

function latToTileY(lat, z) {
  const n = 2 ** z;
  const rad = (lat * Math.PI) / 180;
  const y =
    (1 - Math.log(Math.tan(rad) + 1 / Math.cos(rad)) / Math.PI) / 2;
  return Math.floor(y * n);
}

function tileXToLon(x, z) {
  return (x / 2 ** z) * 360 - 180;
}

function tileYToLat(y, z) {
  const n = Math.PI - (2 * Math.PI * y) / 2 ** z;
  return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
}

function tileUrl(z, x, y) {
  return TILE_URL.replace("{z}", z).replace("{x}", x).replace("{y}", y);
}

// This repo's GeoJSON uses these keys (confirmed via profile_geojson.py):
// - diameter: properties.diam (string)
// - material: properties.material (string)
// - install year: properties.year (string)
const CURRENT_YEAR = 2025;

const MATERIAL_ORDER = [
  "PVC",
  "CI",
  "YDI",
  "PDI",
  "ST",
  "PVCG",
  "CON",
  "DI",
  "AC",
  "PE",
  "CU",
];

// Legend toggles (persist across re-renders)
const filterState = {
  basemapEnabled: true,
  roadsEnabled: false,
  overlay: "none", // style mode: 'none' (asset symbology) | 'risk' | 'consequence' | 'breaks' | 'roads'
  diameterBins: new Set(["≤150", "200–250", "300", "400", "500–600", "≥750", "Unknown"]),
  ageBins: new Set(["<20", "20–50", "50–80", "≥80", "Unknown"]),
  materials: new Set([...MATERIAL_ORDER, "Other", "Unknown"]),
};

async function loadRoadsLayer() {
  try {
    const res = await fetch(roadsUrl, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    roadsGeojson = await res.json();
  } catch (err) {
    roadsGeojson = null;
    console.warn("Roads layer not loaded:", err);
  }
}

function roadUpliftBin(upliftLof) {
  const u = Number(upliftLof);
  if (!Number.isFinite(u) || u <= 0) return null;
  // Uplifts are in 0.5 steps up to 2.0 (per docs/roads_risk.txt).
  if (u >= 2.0) return 4;
  if (u >= 1.5) return 3;
  if (u >= 1.0) return 2;
  return 1;
}

const riskModel = new RiskConsequenceModel({ currentYear: CURRENT_YEAR });

async function loadRoadProximity() {
  // Expected format: { buffer_m: number, byMain: [{globalid, functional_class, uplift_lof, min_dist_m, source_ctp_class}, ...] }
  try {
    const res = await fetch(roadProximityUrl, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    const data = await res.json();
    const rows = Array.isArray(data?.byMain) ? data.byMain : [];
    const map = new Map();

    for (const r of rows) {
      const gid = (r?.globalid ?? "").toString().trim();
      if (!gid) continue;
      const functionalClass = (r?.functional_class ?? "").toString().trim();
      const upliftLof = Number((r?.uplift_lof ?? "").toString().trim());
      const minDistM = Number((r?.min_dist_m ?? "").toString().trim());
      const sourceCtpClass = (r?.source_ctp_class ?? "").toString().trim();

      if (!functionalClass) continue;
      if (!Number.isFinite(upliftLof) || upliftLof <= 0) continue;

      map.set(gid, {
        functionalClass,
        upliftLof,
        minDistM: Number.isFinite(minDistM) ? minDistM : null,
        sourceCtpClass: sourceCtpClass || null,
      });
    }

    roadExposureByGlobalId = map;
    const bm = Number((data?.buffer_m ?? "").toString().trim());
    roadExposureBufferM = Number.isFinite(bm) ? bm : null;

    console.info("Road proximity loaded", {
      mainsWithExposure: roadExposureByGlobalId.size,
      bufferM: roadExposureBufferM,
    });
  } catch (err) {
    // Non-fatal: roads-based risk modifier is optional.
    roadExposureByGlobalId = new Map();
    roadExposureBufferM = null;
    console.warn("Road proximity data not loaded:", err);
  }
}

function isRoadUpliftEligible({ materialCode, ageYears }) {
  const mat = (materialCode ?? "").toString().trim().toUpperCase();
  if (ROAD_AFFECTED_MATERIALS.has(mat)) return true;
  if (mat === "PVC" && typeof ageYears === "number" && Number.isFinite(ageYears)) {
    return ageYears >= OLD_PVC_AGE_YEARS;
  }
  return false;
}

function isOutOfServiceStatus(statusInd) {
  const s = (statusInd ?? "").toString().trim().toUpperCase();
  if (!s) return false;
  // Keep this intentionally strict/minimal: match the same tokens we previously used.
  return s.includes("ABAND") || s.includes("OUT") || s.includes("INACT");
}

function roadMaterialFactor({ materialCode, ageYears } = {}) {
  const mat = (materialCode ?? "").toString().trim().toUpperCase();

  // Evidence base is strongest that traffic loads create localized external stress/strain
  // in buried pipes; we keep a conservative material scaling so the road factor doesn't
  // overwhelm the base material/vintage likelihood.
  if (mat === "CI" || mat === "AC" || mat === "PCI" || mat === "PCCP" || mat === "CON") return 1.0;
  if (mat === "PVC" || mat === "PVCG") {
    // docs/roads_risk.txt calls out "older PVC" specifically.
    if (typeof ageYears === "number" && Number.isFinite(ageYears) && ageYears >= OLD_PVC_AGE_YEARS) return 0.8;
    return 0.4;
  }
  if (mat === "DI" || mat === "PDI" || mat === "YDI" || mat === "ST" || mat === "STEEL") return 0.6;
  if (mat === "PE" || mat === "HDPE") return 0.4;
  return 0.5;
}

function roadDistanceFactor({ minDistM } = {}) {
  const d = Number(minDistM);
  const buffer = Number(roadExposureBufferM);
  if (!Number.isFinite(d) || d < 0) return 1.0;
  if (!Number.isFinite(buffer) || buffer <= 0) return 1.0;

  // docs/roads_risk.txt explicitly recommends *intersection-style* exposure
  // (mains directly under roads), not broad distance-based mapping.
  // Our precompute uses a larger buffer to tolerate geometry misalignment; we
  // therefore gate the uplift to "under / essentially under" distances.
  if (d <= 2.0) return 1.0;
  if (d <= 5.0) return 0.5;
  return 0.0;
}

function applyMajorRoadAdjustment(scored, derived) {
  if (!scored || typeof scored !== "object") return scored;
  if (!roadExposureByGlobalId?.size) return scored;
  const gid = (derived?.globalid ?? "").toString().trim();
  if (!gid) return scored;
  const exp = roadExposureByGlobalId.get(gid);
  if (!exp || typeof exp !== "object") return scored;

  const upliftBase = Number(exp.upliftLof);
  if (!Number.isFinite(upliftBase) || upliftBase <= 0) return scored;

  const eligible = isRoadUpliftEligible({ materialCode: derived?.matCode, ageYears: derived?.ageYears });
  if (!eligible) return scored;

  const materialFactor = roadMaterialFactor({ materialCode: derived?.matCode, ageYears: derived?.ageYears });
  const distanceFactor = roadDistanceFactor({ minDistM: exp.minDistM });
  if (!Number.isFinite(distanceFactor) || distanceFactor <= 0) return scored;

  const upliftApplied = upliftBase * materialFactor * distanceFactor;
  if (!Number.isFinite(upliftApplied) || upliftApplied <= 0.05) return scored;

  const basePofFloat =
    typeof scored.pofFloat === "number" && Number.isFinite(scored.pofFloat)
      ? scored.pofFloat
      : Number(scored.pof ?? 2);
  const basePofLevel = clamp(Number(scored.pof ?? 2), 1, 4);

  const bumpedPofFloat = basePofFloat + upliftApplied;
  const bumpedPofLevel = riskModel.scoreFromFloat01to4(bumpedPofFloat) ?? basePofLevel;

  const cof = clamp(Number(scored.cof ?? 2), 1, 4);
  const riskBin = riskModel.riskBinFromScores(bumpedPofLevel, cof);
  const source = `${(scored.source ?? "").toString()}+roads`;

  return {
    ...scored,
    pof: bumpedPofLevel,
    pofFloat: bumpedPofFloat,
    riskBin,
    source,
    _roadFunctionalClass: (exp.functionalClass ?? "").toString(),
    _roadUpliftLof: upliftApplied,
    _roadUpliftLofBase: upliftBase,
    _roadUpliftFactors: {
      eligible,
      materialFactor,
      distanceFactor,
      bufferM: Number.isFinite(Number(roadExposureBufferM)) ? Number(roadExposureBufferM) : null,
    },
    _roadMinDistM: Number.isFinite(exp.minDistM) ? exp.minDistM : null,
    _pofBaseLevel: basePofLevel,
    _pofBaseFloat: basePofFloat,
    _roadSourceCtpClass: exp.sourceCtpClass ?? null,
  };
}

function formatNumber(x, digits = 2) {
  const n = Number(x);
  if (!Number.isFinite(n)) return "?";
  const d = Math.max(0, Math.min(6, Number(digits)));
  return n.toFixed(d);
}

function formatInspectorText({ props, derived, explanation, adjusted }) {
  const gid = (props?.globalid ?? derived?.globalid ?? "").toString().trim() || "(missing)";
  const pZone = (props?.p_zone ?? derived?.pZone ?? "").toString().trim() || "(unknown)";
  const statusInd = (props?.status_ind ?? derived?.statusInd ?? "").toString().trim() || "";

  const materialRaw = (props?.material ?? "").toString().trim();
  const diamRaw = (props?.diam ?? "").toString().trim();
  const yearRaw = (props?.year ?? "").toString().trim();
  const lengthM =
    Number.isFinite(Number(props?.length)) ? Number(props.length) : (derived?.lengthM ?? null);

  const inputs = explanation?.inputs ?? {};
  const pof = explanation?.pof ?? {};
  const cof = explanation?.cof ?? {};
  const risk = explanation?.risk ?? {};
  const formula = explanation?.formula ?? {};

  const roadFactors = adjusted?._roadUpliftFactors ?? null;
  const roadUpliftApplied = adjusted?._roadUpliftLof;
  const roadUpliftBase = adjusted?._roadUpliftLofBase;
  const roadMinDistM = adjusted?._roadMinDistM;
  const roadClass = adjusted?._roadFunctionalClass;
  const roadSourceCtpClass = adjusted?._roadSourceCtpClass;

  const basePofLevelForRoads = adjusted?._pofBaseLevel ?? null;
  const basePofFloatForRoads = adjusted?._pofBaseFloat ?? null;

  const lines = [];
  lines.push(`GlobalID: ${gid}`);
  lines.push(`p_zone: ${pZone}`);
  if (statusInd) lines.push(`status_ind: ${statusInd}`);
  lines.push("");

  lines.push("Inputs:");
  lines.push(
    `  material: ${materialRaw || "?"}  (raw code: ${inputs.materialCodeRaw ?? "?"}, model code: ${
      inputs.materialCode ?? "?"
    })`
  );
  lines.push(`  diameter: ${diamRaw || "?"}  (mm: ${inputs.diamMm ?? "?"})`);
  lines.push(`  install year: ${yearRaw || "?"}  (year: ${inputs.installYear ?? "?"}, age: ${inputs.ageYears ?? "?"})`);
  lines.push(`  length (m): ${lengthM ?? "?"}`);
  lines.push("");

  lines.push("Risk formula:");
  lines.push(`  ${formula.pof ?? "PoF = clamp(round(...), 1, 4)"}`);
  lines.push(`  ${formula.cof ?? "CoF = clamp(round(...), 1, 4)"}`);
  lines.push(`  ${formula.risk ?? "RiskClass = bin(PoF × CoF)"}`);
  lines.push("");

  lines.push("PoF breakdown:");
  lines.push(`  baseMaterial = ${pof.baseMaterial ?? "?"}`);
  lines.push(`  sizeAdjustment = ${pof.sizeUplift ?? "?"}`);
  lines.push(`  ageAdjustment = ${pof.ageUplift ?? "?"}`);
  lines.push(`  pccpAgeFloor = ${pof.pccpAgeFloor ?? "(none)"}`);
  lines.push(`  vintageFloor = ${pof.vintageFloor ?? "(none)"}`);
  lines.push(`  preRound = ${formatNumber(pof.preRound, 2)}`);
  lines.push(`  PoF (level) = ${pof.level ?? "?"}`);
  lines.push("");

  lines.push("CoF breakdown:");
  lines.push(`  diamScore = ${cof.diamScore ?? "?"}`);
  lines.push(
    `  materialHint = ${cof.materialHint ? `${cof.materialHint.type} ${cof.materialHint.value}` : "(none)"}`
  );
  lines.push(`  lengthAdjustment = ${cof.lengthUplift ?? "?"}`);
  lines.push(`  preRound = ${formatNumber(cof.preRound, 2)}`);
  lines.push(`  CoF (level) = ${cof.level ?? "?"}`);
  lines.push("");

  lines.push("Computed risk:");
  lines.push(`  product = PoF × CoF = ${risk.product ?? "?"}`);
  lines.push(`  RiskClass = ${risk.riskBin ?? "?"} (${risk.riskLabel ?? "?"})`);
  lines.push("");

  lines.push("Major-road adjustment (if applicable):");
  if (roadUpliftApplied == null) {
    lines.push("  (no road adjustment applied)");
  } else {
    const materialFactor = roadFactors?.materialFactor;
    const distanceFactor = roadFactors?.distanceFactor;
    lines.push(`  road functional class = ${roadClass ?? "?"}`);
    if (roadSourceCtpClass) lines.push(`  source ctp_class = ${roadSourceCtpClass}`);
    lines.push(`  minDistM = ${roadMinDistM ?? "?"}`);
    lines.push(`  adjustmentBase = ${roadUpliftBase ?? "?"}`);
    lines.push(`  materialFactor = ${materialFactor ?? "?"}`);
    lines.push(`  distanceFactor = ${distanceFactor ?? "?"}`);
    lines.push(
      `  adjustmentApplied = adjustmentBase × materialFactor × distanceFactor = ${formatNumber(roadUpliftApplied, 2)}`
    );
    if (basePofFloatForRoads != null) {
      lines.push(
        `  PoF_float_after_roads = ${formatNumber(basePofFloatForRoads, 2)} + ${formatNumber(roadUpliftApplied, 2)} = ${formatNumber(
          Number(basePofFloatForRoads) + Number(roadUpliftApplied),
          2
        )}`
      );
    }
    if (basePofLevelForRoads != null) {
      lines.push(`  PoF level: ${basePofLevelForRoads} → ${adjusted?.pof ?? "?"}`);
    }
    lines.push(`  RiskClass after roads = ${adjusted?.riskBin ?? "?"}`);
  }

  // Keep a small footer for provenance.
  lines.push("");
  lines.push(`Source: ${explanation?.source ?? derived?.riskSource ?? "?"}`);

  return lines.join("\n");
}

async function loadBreakDensity() {
  // Expected format: { byZone: [{p_zone, breaks_per_km, ...}, ...] }
  try {
    const res = await fetch(breakDensityUrl, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    const data = await res.json();
    const rows = Array.isArray(data?.byZone) ? data.byZone : [];

    const map = new Map();
    const densities = [];
    for (const r of rows) {
      const zone = (r?.p_zone ?? "").toString().trim() || "(unknown)";
      const v = Number((r?.breaks_per_km ?? "").toString().trim());
      if (Number.isFinite(v)) {
        map.set(zone, v);
        densities.push(v);
      }
    }

    breakDensityByZone = map;

    // Build a stable 4-bin quantile scale (1..4). If all densities are identical,
    // quantiles will repeat; that's ok.
    if (densities.length > 0) {
      breakDensityScale = d3.scaleQuantile().domain(densities).range([1, 2, 3, 4]);
      const qs = breakDensityScale.quantiles();
      const fmt = (n) => {
        if (!Number.isFinite(n)) return "?";
        if (n === 0) return "0";
        const abs = Math.abs(n);
        const digits = abs >= 10 ? 1 : abs >= 1 ? 2 : 3;
        return Number(n).toFixed(digits);
      };
      const labels = [
        `≤ ${fmt(qs[0])}`,
        `${fmt(qs[0])}–${fmt(qs[1])}`,
        `${fmt(qs[1])}–${fmt(qs[2])}`,
        `> ${fmt(qs[2])}`,
      ];
      breakDensityLegend = { labels, palette: BREAK_DENSITY_PALETTE, quantiles: qs };
    } else {
      breakDensityScale = null;
      breakDensityLegend = null;
    }
  } catch (err) {
    // Non-fatal: break-density overlay is optional.
    breakDensityByZone = new Map();
    breakDensityScale = null;
    breakDensityLegend = null;
    console.warn("Break density data not loaded:", err);
  }
}

function lineWidthForLevel(level, k, maxLevel = 4) {
  // Used for Risk/Consequence styling modes.
  const ml = clamp(Number(maxLevel ?? 4), 2, 12);
  const base = 1.4 + (clamp(level, 1, ml) - 1) * 1.0;
  const boost = Math.max(1.0, Math.min(1.6, 1.0 + 0.25 * Math.log2(k + 1)));
  return base * boost;
}

const MATERIAL_COLORS = new Map(
  MATERIAL_ORDER.map((m, i) => [m, d3.schemeTableau10[i % 10]])
);

function normalizeMaterial(raw) {
  const s = (raw ?? "").toString().trim().toUpperCase();
  if (!s) return "Unknown";
  return s;
}

function materialLabel(code, labels) {
  if (!code) return "Unknown";
  const key = code.toString().trim().toUpperCase();
  const label = labels?.[key];
  return label ?? key;
}

function parseDiameterMm(raw) {
  const n = Number((raw ?? "").toString().trim());
  if (!Number.isFinite(n) || n <= 0) return null;
  return n;
}

function parseInstallYear(raw) {
  const s = (raw ?? "").toString();
  const m = s.match(/\b(18|19|20)\d{2}\b/);
  if (!m) return null;
  const y = Number(m[0]);
  if (!Number.isFinite(y) || y < 1800 || y > CURRENT_YEAR) return null;
  return y;
}

function diameterBin(diamMm) {
  if (diamMm == null) return "Unknown";
  if (diamMm <= 150) return "≤150";
  if (diamMm <= 250) return "200–250";
  if (diamMm <= 300) return "300";
  if (diamMm <= 400) return "400";
  if (diamMm <= 600) return "500–600";
  return "≥750";
}

function materialGroup(matCode) {
  if (!matCode || matCode === "Unknown") return "Unknown";
  return MATERIAL_COLORS.has(matCode) ? matCode : "Other";
}

function ageYears(installYear) {
  if (installYear == null) return null;
  const a = CURRENT_YEAR - installYear;
  return a >= 0 ? a : null;
}

function ageBin(age) {
  if (age == null) return "Unknown";
  if (age < 20) return "<20";
  if (age < 50) return "20–50";
  if (age < 80) return "50–80";
  return "≥80";
}

function dashForAgeBin(bin) {
  // NOTE: The paths use `vector-effect: non-scaling-stroke`, which also prevents
  // stroke dash patterns from scaling with zoom transforms. Therefore we should
  // NOT apply any 1/k scaling here; doing so makes dashes look solid when zoomed in.
  const dash = (a, b) => `${a},${b}`;
  const dashDot = (a, b, c, d) => `${a},${b},${c},${d}`;

  switch (bin) {
    case "<20":
      return null; // solid
    case "20–50":
      return dash(10, 6); // dashed
    case "50–80":
      // Use a very short dash with round linecaps to read as dots.
      return dash(0.8, 6);
    case "≥80":
      // Dash-dot: long dash, gap, dot, gap
      return dashDot(10, 6, 0.8, 6);
    default:
      return dash(2, 10); // sparse dashes for unknown
  }
}

function colorForMaterial(mat) {
  if (MATERIAL_COLORS.has(mat)) return MATERIAL_COLORS.get(mat);
  if (mat === "Unknown") return "#6b7280";
  return "#9ca3af";
}

function baseStrokeWidthForDiameter(diamMm) {
  if (diamMm == null) return 0.8;
  if (diamMm <= 150) return 0.8;
  if (diamMm <= 250) return 1.2;
  if (diamMm <= 300) return 1.6;
  if (diamMm <= 400) return 2.2;
  if (diamMm <= 600) return 3.0;
  return 4.0;
}

function strokeWidthPx(diamMm, k) {
  const base = baseStrokeWidthForDiameter(diamMm);
  // Make differences visible at low zoom without exploding at high zoom.
  const boost = Math.max(0.9, Math.min(1.7, 0.9 + 0.35 * Math.log2(k + 1)));
  return base * boost;
}

function minDiameterForZoomK(k) {
  // Level-of-detail filtering to reduce clutter when zoomed out.
  if (k < 1.5) return 400;
  if (k < 4) return 250;
  if (k < 8) return 150;
  return 0;
}

function renderLegend(labels, onToggle) {
  function makeCheckbox({
    listEl,
    label,
    checked,
    kind,
    value,
    swatchEl,
  }) {
    const li = document.createElement("li");
    const key = document.createElement("div");
    key.className = "key";

    const input = document.createElement("input");
    input.type = "checkbox";
    input.checked = !!checked;
    input.dataset.kind = kind;
    if (value != null) input.dataset.value = value;
    input.addEventListener("change", () => onToggle?.(kind, value, input.checked));

    key.appendChild(input);
    if (swatchEl) key.appendChild(swatchEl);
    li.appendChild(key);
    li.appendChild(document.createTextNode(label));
    listEl.appendChild(li);
  }

  function makeKeyItem({ listEl, label, color }) {
    const li = document.createElement("li");
    const key = document.createElement("div");
    key.className = "key";
    const sw = document.createElement("div");
    sw.className = "swatch";
    sw.style.borderTopWidth = "4px";
    sw.style.borderTopColor = color;
    key.appendChild(sw);
    li.appendChild(key);
    li.appendChild(document.createTextNode(label));
    listEl.appendChild(li);
  }

  if (legendOverlayEl) {
    legendOverlayEl.innerHTML = "";
    const swRisk = document.createElement("div");
    swRisk.className = "swatch";
    swRisk.style.borderTopWidth = "4px";
    swRisk.style.borderTopColor = riskModel.riskPalette()[3];
    makeCheckbox({
      listEl: legendOverlayEl,
      label: "Risk",
      checked: filterState.overlay === "risk",
      kind: "overlay",
      value: "risk",
      swatchEl: swRisk,
    });

    const swCof = document.createElement("div");
    swCof.className = "swatch";
    swCof.style.borderTopWidth = "4px";
    swCof.style.borderTopColor = riskModel.consequencePalette()[3];
    makeCheckbox({
      listEl: legendOverlayEl,
      label: "Consequence",
      checked: filterState.overlay === "consequence",
      kind: "overlay",
      value: "consequence",
      swatchEl: swCof,
    });

    if (breakDensityLegend) {
      const swBreaks = document.createElement("div");
      swBreaks.className = "swatch";
      swBreaks.style.borderTopWidth = "4px";
      swBreaks.style.borderTopColor = breakDensityLegend.palette[3];
      makeCheckbox({
        listEl: legendOverlayEl,
        label: "Break density",
        checked: filterState.overlay === "breaks",
        kind: "overlay",
        value: "breaks",
        swatchEl: swBreaks,
      });
    }

    const swRoads = document.createElement("div");
    swRoads.className = "swatch";
    swRoads.style.borderTopWidth = "4px";
    swRoads.style.borderTopColor = riskModel.riskPalette()[3];
    makeCheckbox({
      listEl: legendOverlayEl,
      label: "Road exposure",
      checked: filterState.overlay === "roads",
      kind: "overlay",
      value: "roads",
      swatchEl: swRoads,
    });
  }

  if (legendOverlayKeyTitleEl) {
    const showKey =
      filterState.overlay !== "none" &&
      !(filterState.overlay === "breaks" && !breakDensityLegend);
    legendOverlayKeyTitleEl.style.display = showKey ? "block" : "none";
  }

  if (legendOverlayKeyEl) {
    legendOverlayKeyEl.innerHTML = "";
    if (filterState.overlay !== "none") {
      if (filterState.overlay === "breaks") {
        if (breakDensityLegend) {
          for (let i = 0; i < breakDensityLegend.labels.length; i++) {
            makeKeyItem({
              listEl: legendOverlayKeyEl,
              label: breakDensityLegend.labels[i],
              color: breakDensityLegend.palette[i],
            });
          }
        }
      } else if (filterState.overlay === "roads") {
        // Roads overlay shows *just* the roads-driven LoF adjustment (debug view).
        // Grey = no major-road exposure; colors map to adjustment levels.
        const palette = riskModel.riskPalette();
        makeKeyItem({
          listEl: legendOverlayKeyEl,
          label: "No major road",
          color: "#9ca3af",
        });
        const roadLabels = ["+0.5 LoF", "+1.0 LoF", "+1.5 LoF", "+2.0 LoF"];
        for (let i = 0; i < roadLabels.length; i++) {
          makeKeyItem({
            listEl: legendOverlayKeyEl,
            label: roadLabels[i],
            color: palette[i],
          });
        }
      } else {
        const palette =
          filterState.overlay === "risk" ? riskModel.riskPalette() : riskModel.consequencePalette();
        for (let i = 0; i < riskModel.riskLabels.length; i++) {
          makeKeyItem({
            listEl: legendOverlayKeyEl,
            label: riskModel.riskLabels[i],
            color: palette[i],
          });
        }
      }
    }
  }

  if (legendBasemapEl) {
    legendBasemapEl.innerHTML = "";
    const sw = document.createElement("div");
    sw.className = "swatch";
    sw.style.borderTopWidth = "3px";
    sw.style.borderTopColor = "#9ca3af";
    makeCheckbox({
      listEl: legendBasemapEl,
      label: "OpenStreetMap",
      checked: filterState.basemapEnabled,
      kind: "basemap",
      value: "osm",
      swatchEl: sw,
    });

    const swRoads = document.createElement("div");
    swRoads.className = "swatch";
    swRoads.style.borderTopWidth = "3px";
    swRoads.style.borderTopColor = "#6b7280";
    makeCheckbox({
      listEl: legendBasemapEl,
      label: "Major roads",
      checked: filterState.roadsEnabled,
      kind: "roads",
      value: "roads",
      swatchEl: swRoads,
    });
  }

  if (legendDiameterEl) {
    legendDiameterEl.innerHTML = "";
    const diaItems = [
      { label: "≤150", w: 0.8 },
      { label: "200–250", w: 1.2 },
      { label: "300", w: 1.6 },
      { label: "400", w: 2.2 },
      { label: "500–600", w: 3.0 },
      { label: "≥750", w: 4.0 },
      { label: "Unknown", w: 0.8 },
    ];
    for (const it of diaItems) {
      const sw = document.createElement("div");
      sw.className = "swatch";
      sw.style.borderTopWidth = `${it.w}px`;
      sw.style.borderTopColor = "#111827";
      makeCheckbox({
        listEl: legendDiameterEl,
        label: it.label,
        checked: filterState.diameterBins.has(it.label),
        kind: "diameter",
        value: it.label,
        swatchEl: sw,
      });
    }
  }

  if (legendAgeEl) {
    legendAgeEl.innerHTML = "";
    const ageItems = [
      { label: "<20 years", bin: "<20" },
      { label: "20–50 years", bin: "20–50" },
      { label: "50–80 years", bin: "50–80" },
      { label: "≥80 years", bin: "≥80" },
      { label: "Unknown", bin: "Unknown" },
    ];
    for (const it of ageItems) {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", "44");
      svg.setAttribute("height", "12");
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", "2");
      line.setAttribute("x2", "42");
      line.setAttribute("y1", "6");
      line.setAttribute("y2", "6");
      line.setAttribute("stroke", "#111827");
      line.setAttribute("stroke-width", "3");
      line.setAttribute("stroke-linecap", "round");
      const dash = dashForAgeBin(it.bin);
      if (dash) line.setAttribute("stroke-dasharray", dash);
      svg.appendChild(line);
      makeCheckbox({
        listEl: legendAgeEl,
        label: it.label,
        checked: filterState.ageBins.has(it.bin),
        kind: "age",
        value: it.bin,
        swatchEl: svg,
      });
    }
  }

  if (legendMaterialEl) {
    legendMaterialEl.innerHTML = "";
    const mats = [...MATERIAL_ORDER, "Other", "Unknown"];
    for (const m of mats) {
      const sw = document.createElement("div");
      sw.className = "swatch";
      sw.style.borderTopWidth = "3px";
      sw.style.borderTopColor =
        m === "Other" ? "#9ca3af" : m === "Unknown" ? "#6b7280" : colorForMaterial(m);
      const label =
        m === "Other" || m === "Unknown" ? m : materialLabel(m, labels);
      makeCheckbox({
        listEl: legendMaterialEl,
        label,
        checked: filterState.materials.has(m),
        kind: "material",
        value: m,
        swatchEl: sw,
      });
    }
  }
}

function showError(err) {
  if (statusEl) statusEl.remove();
  const div = document.createElement("div");
  div.className = "error";
  div.textContent = `Failed to load/render GeoJSON.\n\n${err?.message ?? err}`;
  container.appendChild(div);
}

function clearStatus() {
  if (statusEl) statusEl.remove();
}

function createSvg(width, height) {
  const svg = d3
    .select(container)
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", `0 0 ${width} ${height}`)
    .attr("preserveAspectRatio", "xMidYMid meet");

  return svg;
}

function ensureTileLayer() {
  if (!tilesEl) return null;
  let layer = tilesEl.querySelector(".tile-layer");
  if (!layer) {
    layer = document.createElement("div");
    layer.className = "tile-layer";
    tilesEl.appendChild(layer);
  }
  return layer;
}

function summarizeProperties(properties, labels) {
  if (!properties || typeof properties !== "object") return "(no properties)";

  const diamMm = parseDiameterMm(properties.diam);
  const material = normalizeMaterial(properties.material);
  const materialName = materialLabel(material, labels);
  const iy = parseInstallYear(properties.year);
  const age = ageYears(iy);

  const matCode = normalizeMaterial(properties.material);
  const statusInd = (properties.status_ind ?? "").toString();
  const lengthM = Number.isFinite(Number(properties.length)) ? Number(properties.length) : null;
  const ageYearsValue = age;

  const scored = riskModel.compute({
    materialCode: matCode,
    diamMm,
    installYear: iy,
    lengthM,
  });
  const gid = (properties.globalid ?? "").toString().trim();
  const expRaw = gid ? roadExposureByGlobalId.get(gid) : null;
  const roadEligible = isRoadUpliftEligible({ materialCode: matCode, ageYears: ageYearsValue });
  const derivedForRoads = { globalid: gid, matCode, ageYears: ageYearsValue };
  const adj = applyMajorRoadAdjustment(scored, derivedForRoads);
  const { pof, cof, riskBin: rbin, source, pofSource, cofSource, pofSizeUplift } = adj;

  const lines = [];
  lines.push(`diam: ${diamMm ?? "Unknown"}${diamMm != null ? " mm" : ""}`);
  lines.push(`material: ${materialName}`);
  lines.push(`year: ${iy ?? "Unknown"}`);
  lines.push(`age: ${age ?? "Unknown"}${age != null ? " yrs" : ""}`);
  lines.push(`risk: ${riskModel.riskLabels[rbin - 1]} (PoF ${pof} × CoF ${cof})`);
  lines.push(`consequence: ${riskModel.riskLabels[cof - 1]} (${cof})`);
  {
    const ps = (pofSource ?? "").toString().trim() || null;
    const cs = (cofSource ?? "").toString().trim() || null;
    const parts = [];
    if (ps) parts.push(`PoF ${ps}`);
    if (cs) parts.push(`CoF ${cs}`);
    const sizeAdj =
      typeof pofSizeUplift === "number" && Number.isFinite(pofSizeUplift) && pofSizeUplift > 0
        ? `; +${pofSizeUplift} small-diameter PoF adjustment`
        : "";
    const detail = parts.length ? ` (${parts.join(", ")}${sizeAdj})` : sizeAdj ? ` (${sizeAdj.slice(2)})` : "";
    lines.push(`risk source: ${source}${detail}`);
  }

  if (gid) lines.push(`globalid: ${gid}`);

  if (expRaw && typeof expRaw === "object") {
    const bm = Number.isFinite(roadExposureBufferM) ? roadExposureBufferM : null;
    const bmTxt = bm != null ? ` (≤${bm}m)` : "";
    const distTxt = Number.isFinite(expRaw?.minDistM)
      ? ` (min ${Number(expRaw.minDistM).toFixed(1)} m)`
      : "";
    const cls = (expRaw?.functionalClass ?? "").toString().trim();
    const ctp = (expRaw?.sourceCtpClass ?? "").toString().trim();
    const clsTxt = cls ? ` ${cls}` : "";
    const ctpTxt = ctp ? ` [${ctp}]` : "";
    const uplift = Number(expRaw?.upliftLof);
    const upliftTxt = Number.isFinite(uplift) ? ` (+${uplift} LoF adjustment)` : "";
    lines.push(`major road exposure (raw)${bmTxt}: yes${clsTxt}${ctpTxt}${distTxt}${upliftTxt}`);
    lines.push(`major road adjustment eligible: ${roadEligible ? "yes" : "no"}`);
  } else {
    lines.push("major road exposure (raw): no");
  }

  if (Number.isFinite(adj?._roadUpliftLof)) {
    const bm = Number.isFinite(roadExposureBufferM) ? roadExposureBufferM : null;
    const bmTxt = bm != null ? ` (≤${bm}m)` : "";
    const distTxt = Number.isFinite(adj?._roadMinDistM)
      ? ` (min ${Number(adj._roadMinDistM).toFixed(1)} m)`
      : "";
    const cls = (adj?._roadFunctionalClass ?? "").toString().trim();
    const ctp = (adj?._roadSourceCtpClass ?? "").toString().trim();
    const clsTxt = cls ? ` ${cls}` : "";
    const ctpTxt = ctp ? ` [${ctp}]` : "";

    const baseLevel = Number.isFinite(adj?._pofBaseLevel) ? adj._pofBaseLevel : null;
    const bumpTxt =
      baseLevel != null && baseLevel !== pof ? ` (LoF ${baseLevel}→${pof}, +${adj._roadUpliftLof})` : "";
    lines.push(`major road adjustment applied${bmTxt}: yes${clsTxt}${ctpTxt}${distTxt}${bumpTxt}`);
  }

  const zone = (properties.p_zone ?? "").toString().trim();
  if (zone && breakDensityByZone?.size) {
    const v = breakDensityByZone.get(zone);
    if (Number.isFinite(v)) {
      lines.push(`breaks/km (zone): ${Number(v).toFixed(3)}`);
    }
  }

  // Add a couple extra fields if present.
  for (const k of ["status_ind", "p_zone", "length"]) {
    if (properties[k] != null && properties[k] !== "") {
      lines.push(`${k}: ${properties[k]}`);
    }
  }

  return lines.join("\n");
}

function setTooltip(text, x, y) {
  if (!tooltipEl) return;
  if (!text) {
    tooltipEl.style.transform = "translate(-9999px, -9999px)";
    tooltipEl.setAttribute("aria-hidden", "true");
    return;
  }

  tooltipEl.textContent = text;
  tooltipEl.setAttribute("aria-hidden", "false");
  tooltipEl.style.transform = `translate(${x + 12}px, ${y + 12}px)`;
}

function render(geojson, labels) {
  container.querySelectorAll("svg").forEach((n) => n.remove());

  const tileLayer = ensureTileLayer();
  if (tileLayer) tileLayer.innerHTML = "";

  const { width, height } = container.getBoundingClientRect();
  const w = Math.max(320, Math.floor(width));
  const h = Math.max(240, Math.floor(height));

  const svg = createSvg(w, h);

  const projection = d3.geoMercator();
  const path = d3.geoPath(projection);

  // Fit projection to data.
  projection.fitSize([w, h], geojson);

  // On first render, restore URL state (zoom + filters). Subsequent re-renders
  // (e.g., resize) should preserve the in-memory state.
  if (!urlState.initialized) {
    readUrlStateIntoFilterState();
    urlState.initialized = true;
  }

  let currentTransform = urlState.transform ?? d3.zoomIdentity;

  let roadsG = null;

  function applyBasemapVisibility() {
    if (!tilesEl) return;
    tilesEl.style.display = filterState.basemapEnabled ? "block" : "none";
  }

  function applyRoadsVisibility() {
    // roads layer is SVG-based, so we toggle it independently of the raster tiles.
    if (!roadsG) return;
    roadsG.style("display", filterState.roadsEnabled ? null : "none");
  }

  function onToggle(kind, value, checked) {
    if (kind === "overlay") {
      // Mutually exclusive overlays.
      if (checked) filterState.overlay = value;
      else if (filterState.overlay === value) filterState.overlay = "none";

      updateSymbology(currentTransform.k);
      renderLegend(labels, onToggle);
      scheduleUrlWrite(currentTransform);
      return;
    }

    if (kind === "basemap") {
      filterState.basemapEnabled = checked;
      applyBasemapVisibility();
      updateTiles(currentTransform);
      scheduleUrlWrite(currentTransform);
      return;
    }

    if (kind === "roads") {
      filterState.roadsEnabled = checked;
      applyRoadsVisibility();
      scheduleUrlWrite(currentTransform);
      return;
    }

    if (kind === "diameter") {
      if (checked) filterState.diameterBins.add(value);
      else filterState.diameterBins.delete(value);
    }

    if (kind === "age") {
      if (checked) filterState.ageBins.add(value);
      else filterState.ageBins.delete(value);
    }

    if (kind === "material") {
      if (checked) filterState.materials.add(value);
      else filterState.materials.delete(value);
    }

    updateSymbology(currentTransform.k);
    if (filterState.overlay === "risk") renderLegend(labels, onToggle);
    scheduleUrlWrite(currentTransform);
  }

  renderLegend(labels, onToggle);
  applyBasemapVisibility();

  roadsG = svg.append("g").attr("class", "layer roads-layer");
  const g = svg.append("g").attr("class", "layer main-layer");

  const zoom = d3
    .zoom()
    .scaleExtent([1, 20])
    .on("zoom", (event) => {
      currentTransform = event.transform;
      urlState.transform = currentTransform;
      roadsG.attr("transform", event.transform);
      g.attr("transform", event.transform);
      updateSymbology(event.transform.k);
      updateTiles(event.transform);
      scheduleUrlWrite(event.transform);
    });

  svg.call(zoom);

  function featureId(d, i) {
    return d?.id ?? d?.properties?.OBJECTID ?? d?.properties?.ObjectId ?? i;
  }

  let features =
    geojson.type === "FeatureCollection" ? geojson.features : [geojson];

  // Remove abandoned/out-of-service mains from the map entirely.
  // (Do not try to "score" them differently.)
  features = features.filter((f) => !isOutOfServiceStatus(f?.properties?.status_ind));

  // Roads layer (optional)
  const roadFeatures =
    roadsGeojson && roadsGeojson.type === "FeatureCollection"
      ? roadsGeojson.features
      : roadsGeojson
        ? [roadsGeojson]
        : [];

  roadsG
    .selectAll("path")
    .data(roadFeatures, featureId)
    .join("path")
    .attr("class", "road")
    .attr("d", path);

  // Apply initial visibility after roadsG exists.
  applyRoadsVisibility();

  // Compute derived values once for faster styling + filtering.
  for (const f of features) {
    const props = f?.properties ?? {};
    const diamMm = parseDiameterMm(props.diam);
    const diamBin = diameterBin(diamMm);
    const matCode = normalizeMaterial(props.material);
    const matGroup = materialGroup(matCode);
    const iy = parseInstallYear(props.year);
    const a = ageYears(iy);
    const aBin = ageBin(a);

    const statusInd = (props.status_ind ?? "").toString();
    const lengthN = Number((props.length ?? "").toString().trim());
    const lengthM = Number.isFinite(lengthN) ? lengthN : null;

    const pZone = (props.p_zone ?? "").toString().trim() || "(unknown)";
    const globalid = (props.globalid ?? "").toString().trim();

    const derived = {
      diamMm,
      diamBin,
      matCode,
      matGroup,
      installYear: iy,
      ageYears: a,
      ageBin: aBin,
      statusInd,
      lengthM,
      pZone,
      globalid,
    };

    const scored = riskModel.compute({
      materialCode: derived.matCode,
      diamMm: derived.diamMm,
      installYear: derived.installYear,
      lengthM: derived.lengthM,
    });
    const adj = applyMajorRoadAdjustment(scored, derived);
    const { pof, cof, riskBin, source, pofSource, cofSource, pofSizeUplift } = adj;
    derived.pof = pof;
    derived.cof = cof;
    derived.pofFloat =
      typeof adj?.pofFloat === "number" && Number.isFinite(adj.pofFloat) ? adj.pofFloat : pof;
    derived.cofFloat =
      typeof adj?.cofFloat === "number" && Number.isFinite(adj.cofFloat) ? adj.cofFloat : cof;
    derived.riskScoreFloat =
      typeof derived.pofFloat === "number" &&
      Number.isFinite(derived.pofFloat) &&
      typeof derived.cofFloat === "number" &&
      Number.isFinite(derived.cofFloat)
        ? derived.pofFloat * derived.cofFloat
        : null;
    derived.riskBin = riskBin;
    derived.riskSource = source;
    derived.pofSource = (pofSource ?? "").toString().trim() || null;
    derived.cofSource = (cofSource ?? "").toString().trim() || null;
    derived.pofSizeUplift = Number.isFinite(Number(pofSizeUplift)) ? Number(pofSizeUplift) : null;
    derived.roadFunctionalClass = (adj?._roadFunctionalClass ?? "").toString().trim() || null;
    derived.roadUpliftLof = Number.isFinite(adj?._roadUpliftLof) ? adj._roadUpliftLof : null;
    derived.roadMinDistM = Number.isFinite(adj?._roadMinDistM) ? adj._roadMinDistM : null;

    const breaksPerKm = breakDensityByZone?.get(pZone);
    derived.breaksPerKm = Number.isFinite(breaksPerKm) ? breaksPerKm : null;
    if (derived.breaksPerKm != null && breakDensityScale) {
      derived.breaksBin = breakDensityScale(derived.breaksPerKm);
    } else {
      derived.breaksBin = null;
    }
    f._derived = derived;
  }

  const paths = g
    .selectAll("path")
    .data(features)
    .join("path")
    .attr("class", "feature")
    .attr("d", path)
    .each(function (d) {
      // Ensure no stale selection classes survive re-render.
      d3.select(this).classed("is-selected", false);
    })
    .on("mouseenter", function () {
      d3.select(this).classed("is-hover", true);
    })
    .on("mousemove", function (event, d) {
      const [mx, my] = d3.pointer(event, container);
      const text = summarizeProperties(d?.properties, labels);
      setTooltip(text, mx, my);
    })
    .on("mouseleave", function () {
      d3.select(this).classed("is-hover", false);
      setTooltip(null);
    })
    .on("click", function (event, d) {
      event.preventDefault();
      event.stopPropagation();

      const props = d?.properties ?? {};
      const derived = d?._derived ?? {};

      const gid = (props.globalid ?? derived.globalid ?? "").toString().trim();
      const materialRaw = (props.material ?? "").toString().trim();
      const diamRaw = (props.diam ?? "").toString().trim();
      const yearRaw = (props.year ?? "").toString().trim();

      const matCode = derived.matCode ?? normalizeMaterial(materialRaw);
      const diamMm = derived.diamMm ?? parseDiameterMm(diamRaw);
      const installYear = derived.installYear ?? parseInstallYear(yearRaw);
      const ageY = derived.ageYears ?? ageYears(installYear);
      const pZone = (props.p_zone ?? derived.pZone ?? "").toString().trim();

      const exp = gid ? roadExposureByGlobalId.get(gid) : null;
      const eligible = isRoadUpliftEligible({ materialCode: matCode, ageYears: ageY });

      const debug = {
        at: new Date().toISOString(),
        overlayMode: filterState.overlay ?? "none",
        basemapEnabled: !!filterState.basemapEnabled,
        roadsLayerEnabled: !!filterState.roadsEnabled,
        view: {
          k: Number(currentTransform?.k),
          x: Number(currentTransform?.x),
          y: Number(currentTransform?.y),
        },
        pipe: {
          globalid: gid || null,
          p_zone: pZone || null,
          materialRaw: materialRaw || null,
          matCode,
          diamRaw: diamRaw || null,
          diamMm: Number.isFinite(diamMm) ? diamMm : null,
          yearRaw: yearRaw || null,
          installYear: Number.isFinite(installYear) ? installYear : null,
          ageYears: Number.isFinite(ageY) ? ageY : null,
          status_ind: (props.status_ind ?? derived.statusInd ?? "").toString() || null,
          lengthM: Number.isFinite(Number(props.length)) ? Number(props.length) : derived.lengthM ?? null,
        },
        risk: {
          pof: derived.pof ?? null,
          cof: derived.cof ?? null,
          riskBin: derived.riskBin ?? null,
          riskLabel:
            Number.isFinite(Number(derived.riskBin)) && Number(derived.riskBin) >= 1 && Number(derived.riskBin) <= 4
              ? riskModel.riskLabels[Number(derived.riskBin) - 1]
              : null,
          source: derived.riskSource ?? null,
        },
        roads: {
          buffer_m: roadExposureBufferM,
          rawExposure: exp
            ? {
                functionalClass: exp.functionalClass ?? null,
                upliftLof: Number.isFinite(Number(exp.upliftLof)) ? Number(exp.upliftLof) : null,
                minDistM: Number.isFinite(Number(exp.minDistM)) ? Number(exp.minDistM) : null,
                sourceCtpClass: exp.sourceCtpClass ?? null,
              }
            : null,
          eligibleForUplift: eligible,
          applied: {
            functionalClass: derived.roadFunctionalClass ?? null,
            upliftLof: derived.roadUpliftLof ?? null,
            minDistM: derived.roadMinDistM ?? null,
          },
        },
        breaks: {
          breaksPerKm: derived.breaksPerKm ?? null,
          breaksBin: derived.breaksBin ?? null,
        },
      };

      // Dev-friendly console output.
      console.groupCollapsed(`PIPE DEBUG ${gid ? gid : "(no globalid)"}`);
      console.log(debug);
      console.log("properties", props);
      console.log("derived", derived);
      console.groupEnd();

      // Build and show the on-click inspector popup.
      if (inspectorEl && inspectorPreEl) {
        // Clear prior selection highlight.
        paths.filter(".is-selected").classed("is-selected", false);
        d3.select(this).classed("is-selected", true);

        const lengthMForExplain = Number.isFinite(Number(props.length))
          ? Number(props.length)
          : (derived.lengthM ?? null);

        const explanation = riskModel.explain({
          materialCode: matCode,
          diamMm,
          installYear,
          lengthM: typeof lengthMForExplain === "number" && Number.isFinite(lengthMForExplain) ? lengthMForExplain : null,
        });

        const scored = riskModel.compute({
          materialCode: matCode,
          diamMm,
          installYear,
          lengthM: typeof lengthMForExplain === "number" && Number.isFinite(lengthMForExplain) ? lengthMForExplain : null,
        });
        const adjusted = applyMajorRoadAdjustment(scored, derived);

        inspectorPreEl.textContent = formatInspectorText({ props, derived, explanation, adjusted });
        inspectorEl.hidden = false;
      }
    });

  function updateSymbology(k) {
    const minDiam = minDiameterForZoomK(k);

    const styleMode = filterState.overlay ?? "none";

    function passesFilters(d) {
      const derived = d?._derived;
      const diamBin = derived?.diamBin ?? diameterBin(derived?.diamMm ?? parseDiameterMm(d?.properties?.diam));
      const matGroup =
        derived?.matGroup ?? materialGroup(derived?.matCode ?? normalizeMaterial(d?.properties?.material));
      const aBin = derived?.ageBin ?? ageBin(ageYears(parseInstallYear(d?.properties?.year)));
      if (!filterState.diameterBins.has(diamBin)) return false;
      if (!filterState.materials.has(matGroup)) return false;
      if (!filterState.ageBins.has(aBin)) return false;
      return true;
    }

    function passesLod(d) {
      if (minDiam <= 0) return true;
      const derived = d?._derived;
      const diamMm = derived?.diamMm ?? parseDiameterMm(d?.properties?.diam);
      if (diamMm == null) return false;
      return diamMm >= minDiam;
    }


    paths
      .attr("stroke-linecap", "round")
      .attr("stroke", (d) => {
        const derived = d?._derived;
        if (styleMode === "risk") {
          const bin = clamp(Number(derived?.riskBin ?? 2), 1, 4);
          return riskModel.riskPalette()[bin - 1];
        }
        if (styleMode === "consequence") {
          const cof = clamp(Number(derived?.cof ?? 2), 1, 4);
          return riskModel.consequencePalette()[cof - 1];
        }
        if (styleMode === "breaks") {
          const bin = Number(derived?.breaksBin);
          if (Number.isFinite(bin)) {
            return BREAK_DENSITY_PALETTE[clamp(bin, 1, 4) - 1];
          }
          return "#9ca3af";
        }
        if (styleMode === "roads") {
          const upliftBin = roadUpliftBin(derived?.roadUpliftLof);
          if (upliftBin != null) return riskModel.riskPalette()[upliftBin - 1];
          return "#9ca3af";
        }

        const matCode = derived?.matCode ?? normalizeMaterial(d?.properties?.material);
        if (matCode !== "Unknown" && !MATERIAL_COLORS.has(matCode)) return "#9ca3af";
        return colorForMaterial(matCode);
      })
      .attr("stroke-dasharray", (d) => {
        if (
          styleMode === "risk" ||
          styleMode === "consequence" ||
          styleMode === "breaks" ||
          styleMode === "roads"
        )
          return null;
        const bin = d?._derived?.ageBin ?? ageBin(ageYears(parseInstallYear(d?.properties?.year)));
        const dash = dashForAgeBin(bin);
        return dash ?? null;
      })
      .attr("stroke-width", (d) => {
        const derived = d?._derived;
        if (styleMode === "risk") {
          const bin = clamp(Number(derived?.riskBin ?? 2), 1, 4);
          return lineWidthForLevel(bin, k, 4);
        }
        if (styleMode === "consequence") {
          const cof = clamp(Number(derived?.cof ?? 2), 1, 4);
          return lineWidthForLevel(cof, k);
        }
        if (styleMode === "breaks") {
          const diamMm = derived?.diamMm ?? parseDiameterMm(d?.properties?.diam);
          return strokeWidthPx(diamMm, k);
        }
        if (styleMode === "roads") {
          const upliftBin = roadUpliftBin(derived?.roadUpliftLof);
          const lvl = upliftBin != null ? upliftBin : 1;
          return lineWidthForLevel(lvl, k);
        }
        const diamMm = derived?.diamMm ?? parseDiameterMm(d?.properties?.diam);
        return strokeWidthPx(diamMm, k);
      })
      .style("display", (d) => {
        const derived = d?._derived;
        const diamMm = derived?.diamMm ?? parseDiameterMm(d?.properties?.diam);
        const diamBin = derived?.diamBin ?? diameterBin(diamMm);
        const matGroup = derived?.matGroup ?? materialGroup(normalizeMaterial(d?.properties?.material));
        const aBin = derived?.ageBin ?? ageBin(ageYears(parseInstallYear(d?.properties?.year)));

        if (!filterState.diameterBins.has(diamBin)) return "none";
        if (!filterState.materials.has(matGroup)) return "none";
        if (!filterState.ageBins.has(aBin)) return "none";

        if (minDiam <= 0) return null;
        if (diamMm == null) return "none";
        return diamMm >= minDiam ? null : "none";
      });
  }

  // Raster tiles: compute visible tiles for the current zoom transform.
  function updateTiles(transform) {
    if (!filterState.basemapEnabled) return;
    if (!tileLayer) return;

    // Apply the same transform to tiles so panning/zooming stays perfectly in sync.
    tileLayer.style.transform = `translate(${transform.x}px, ${transform.y}px) scale(${transform.k})`;

    // Derive a tile zoom level based on mercator scale.
    const worldPx = projection.scale() * 2 * Math.PI;
    const z0 = Math.log2(worldPx / 256);
    const z = clamp(Math.round(z0 + Math.log2(transform.k)), 0, TILE_MAX_Z);

    // Visible extent in *base* (untransformed) pixels.
    const x0 = (0 - transform.x) / transform.k;
    const y0 = (0 - transform.y) / transform.k;
    const x1 = (w - transform.x) / transform.k;
    const y1 = (h - transform.y) / transform.k;

    const p0 = projection.invert([x0, y0]);
    const p1 = projection.invert([x1, y1]);
    if (!p0 || !p1) return;

    const lonMin = Math.min(p0[0], p1[0]);
    const lonMax = Math.max(p0[0], p1[0]);
    const latMin = Math.min(p0[1], p1[1]);
    const latMax = Math.max(p0[1], p1[1]);

    const n = 2 ** z;
    let xMin = clamp(lonToTileX(lonMin, z) - 1, 0, n - 1);
    let xMax = clamp(lonToTileX(lonMax, z) + 1, 0, n - 1);
    let yMin = clamp(latToTileY(latMax, z) - 1, 0, n - 1); // top
    let yMax = clamp(latToTileY(latMin, z) + 1, 0, n - 1); // bottom

    // Guard against pathological inversions.
    if (xMax < xMin || yMax < yMin) return;

    const tiles = [];
    for (let ty = yMin; ty <= yMax; ty++) {
      for (let tx = xMin; tx <= xMax; tx++) {
        tiles.push({ z, x: tx, y: ty, key: `${z}/${tx}/${ty}` });
      }
    }

    const join = d3
      .select(tileLayer)
      .selectAll("img")
      .data(tiles, (d) => d.key);

    join.exit().remove();

    join
      .enter()
      .append("img")
      .attr("alt", "")
      .attr("loading", "lazy")
      .attr("referrerpolicy", "no-referrer")
      .attr("src", (d) => tileUrl(d.z, d.x, d.y))
      .merge(join)
      .each(function (d) {
        // Project tile bounds to our base pixel coordinate space.
        const lonL = tileXToLon(d.x, d.z);
        const lonR = tileXToLon(d.x + 1, d.z);
        const latT = tileYToLat(d.y, d.z);
        const latB = tileYToLat(d.y + 1, d.z);

        const pTL = projection([lonL, latT]);
        const pBR = projection([lonR, latB]);
        if (!pTL || !pBR) return;

        const left = pTL[0];
        const top = pTL[1];
        const widthPx = pBR[0] - pTL[0];
        const heightPx = pBR[1] - pTL[1];

        const img = this;
        img.style.left = `${left}px`;
        img.style.top = `${top}px`;
        img.style.width = `${widthPx}px`;
        img.style.height = `${heightPx}px`;
      });
  }

  // Apply initial/restore transform (triggers zoom handler, symbology, tiles).
  svg.call(zoom.transform, currentTransform);

  // If the URL selected Risk overlay on load, refresh the legend once the
  // risk quantiles have been computed.
  if (filterState.overlay === "risk") renderLegend(labels, onToggle);

  // Ensure URL reflects the current state even if the page loads with defaults.
  scheduleUrlWrite(currentTransform);

  svg.on("click", () => {
    // Click off-feature: clear selection + close inspector.
    g.selectAll("path.feature").classed("is-selected", false);
    if (inspectorEl) inspectorEl.hidden = true;
  });
}

async function main() {
  try {
    initHelpPanel();
    initLegendToggle();
    initInspector();
    await Promise.all([
      loadBreakDensity(),
      loadRoadProximity(),
      loadRoadsLayer(),
    ]);
    const [geojson, labels] = await Promise.all([
      d3.json(geojsonUrl),
      d3.json(materialLabelsUrl).catch(() => ({})),
    ]);
    clearStatus();
    render(geojson, labels);

    // Re-render on resize to keep it fitting the viewport.
    let resizeRaf = null;
    window.addEventListener("resize", () => {
      if (resizeRaf) cancelAnimationFrame(resizeRaf);
      resizeRaf = requestAnimationFrame(() => render(geojson, labels));
    });
  } catch (err) {
    showError(err);
  }
}

main();
