import { RiskConsequenceModel } from "./risk_consequence.js";

const container = document.getElementById("map");
const statusEl = document.getElementById("status");
const tooltipEl = document.getElementById("tooltip");
const legendOverlayEl = document.getElementById("legendOverlay");
const legendOverlayKeyTitleEl = document.getElementById("legendOverlayKeyTitle");
const legendOverlayKeyEl = document.getElementById("legendOverlayKey");
const legendDiameterEl = document.getElementById("legendDiameter");
const legendAgeEl = document.getElementById("legendAge");
const legendMaterialEl = document.getElementById("legendMaterial");
const legendBasemapEl = document.getElementById("legendBasemap");
const tilesEl = document.getElementById("tiles");
const legendEl = document.getElementById("legend");
const legendToggleEl = document.getElementById("legendToggle");
const legendBodyEl = document.getElementById("legendBody");

const geojsonUrl = "./data/Public_Water_Main_20251231.geojson";
const materialLabelsUrl = "./material_labels.json";
const riskCsvUrl = "./docs/distinct_material_diameter_year_with_risk.csv";
const breakDensityUrl = "./docs/break_density_by_p_zone.json";
const roadProximityUrl = "./docs/road_proximity_by_main.json";

// Loaded from docs/break_density_by_p_zone.json (generated by tools/break_density_by_p_zone.py)
let breakDensityByZone = new Map(); // p_zone -> breaks_per_km
let breakDensityScale = null; // d3.scaleQuantile returning 1..4
let breakDensityLegend = null; // { labels: string[], palette: string[], quantiles: number[] }

// Loaded from docs/road_proximity_by_main.json (generated by tools/major_roads_over_mains.py)
let roadExposureByGlobalId = new Map();
// globalid -> { functionalClass: string, upliftLof: number, minDistM: number|null, sourceCtpClass: string|null }
let roadExposureBufferM = null;

const ROAD_AFFECTED_MATERIALS = new Set(["CI", "AC", "PCI", "PCCP"]);
const OLD_PVC_AGE_YEARS = 40;

// Tailwind-like blues (already used elsewhere in the project via hex codes).
const BREAK_DENSITY_PALETTE = ["#dbeafe", "#93c5fd", "#3b82f6", "#1d4ed8"];

function setLegendCollapsed(isCollapsed) {
  if (!legendEl || !legendToggleEl) return;
  legendEl.classList.toggle("is-collapsed", !!isCollapsed);
  legendToggleEl.setAttribute("aria-expanded", isCollapsed ? "false" : "true");
  legendToggleEl.textContent = isCollapsed ? "Show" : "Hide";
  if (legendBodyEl) legendBodyEl.setAttribute("aria-hidden", isCollapsed ? "true" : "false");
}

function initLegendToggle() {
  if (!legendEl || !legendToggleEl) return;

  const isSmall = window.matchMedia?.("(max-width: 640px)")?.matches ?? false;
  // On mobile: start collapsed. On desktop: start expanded.
  setLegendCollapsed(!!isSmall);

  legendToggleEl.addEventListener("click", () => {
    const isCollapsed =
      legendToggleEl.getAttribute("aria-expanded") === "false" ||
      legendEl.classList.contains("is-collapsed");
    setLegendCollapsed(!isCollapsed);
  });
}

// URL state (shareable view): stores zoom/pan + current filters in the query string.
// Example:
//   ?k=2.1&x=-120&y=85&bm=1&dia=%E2%89%A4150,300&age=%3C20,20%E2%80%9350&mat=PVC,Other
const urlState = {
  initialized: false,
  transform: d3.zoomIdentity,
  _pending: false,
};

function parseCsvParam(params, key) {
  const raw = params.get(key);
  if (raw == null) return null;
  const trimmed = raw.trim();
  if (!trimmed) return [];
  return trimmed
    .split(",")
    .map((s) => s.trim())
    .filter((s) => s.length > 0);
}

function readUrlStateIntoFilterState() {
  const params = new URLSearchParams(window.location.search);

  // Zoom transform
  const k = Number(params.get("k"));
  const x = Number(params.get("x"));
  const y = Number(params.get("y"));
  if (Number.isFinite(k) && k > 0 && Number.isFinite(x) && Number.isFinite(y)) {
    urlState.transform = d3.zoomIdentity.translate(x, y).scale(k);
  }

  // Basemap
  const bm = params.get("bm");
  if (bm != null) {
    filterState.basemapEnabled = bm === "1" || bm.toLowerCase() === "true";
  }

  // Overlay
  const ov = (params.get("ov") ?? "").toString().trim().toLowerCase();
  if (ov === "risk" || ov === "consequence" || ov === "breaks" || ov === "none") {
    filterState.overlay = ov;
  }

  // Filters
  const dia = parseCsvParam(params, "dia");
  if (dia != null) {
    filterState.diameterBins = new Set(dia);
  }

  const age = parseCsvParam(params, "age");
  if (age != null) {
    filterState.ageBins = new Set(age);
  }

  const mat = parseCsvParam(params, "mat");
  if (mat != null) {
    filterState.materials = new Set(mat);
  }
}

function writeUrlState(transform) {
  const params = new URLSearchParams(window.location.search);

  // Keep params stable (so sharing URLs is predictable).
  const k = Number(transform?.k);
  const x = Number(transform?.x);
  const y = Number(transform?.y);
  if (Number.isFinite(k) && Number.isFinite(x) && Number.isFinite(y)) {
    params.set("k", k.toFixed(4));
    params.set("x", x.toFixed(2));
    params.set("y", y.toFixed(2));
  } else {
    params.delete("k");
    params.delete("x");
    params.delete("y");
  }

  params.set("bm", filterState.basemapEnabled ? "1" : "0");
  params.set("ov", filterState.overlay ?? "none");
  params.set("dia", [...filterState.diameterBins].join(","));
  params.set("age", [...filterState.ageBins].join(","));
  params.set("mat", [...filterState.materials].join(","));

  const next = `${window.location.pathname}?${params.toString()}${window.location.hash}`;
  const current = `${window.location.pathname}${window.location.search}${window.location.hash}`;
  if (next !== current) {
    history.replaceState(null, "", next);
  }
}

function scheduleUrlWrite(transform) {
  urlState.transform = transform;
  if (urlState._pending) return;
  urlState._pending = true;
  window.requestAnimationFrame(() => {
    urlState._pending = false;
    writeUrlState(urlState.transform);
  });
}

// Online basemap tiles (OpenStreetMap). For production usage, use an approved tile provider.
const TILE_URL = "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
const TILE_MAX_Z = 19;

function clamp(n, lo, hi) {
  return Math.max(lo, Math.min(hi, n));
}

function lonToTileX(lon, z) {
  const n = 2 ** z;
  return Math.floor(((lon + 180) / 360) * n);
}

function latToTileY(lat, z) {
  const n = 2 ** z;
  const rad = (lat * Math.PI) / 180;
  const y =
    (1 - Math.log(Math.tan(rad) + 1 / Math.cos(rad)) / Math.PI) / 2;
  return Math.floor(y * n);
}

function tileXToLon(x, z) {
  return (x / 2 ** z) * 360 - 180;
}

function tileYToLat(y, z) {
  const n = Math.PI - (2 * Math.PI * y) / 2 ** z;
  return (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
}

function tileUrl(z, x, y) {
  return TILE_URL.replace("{z}", z).replace("{x}", x).replace("{y}", y);
}

// This repo's GeoJSON uses these keys (confirmed via profile_geojson.py):
// - diameter: properties.diam (string)
// - material: properties.material (string)
// - install year: properties.year (string)
const CURRENT_YEAR = 2025;

const MATERIAL_ORDER = [
  "PVC",
  "CI",
  "YDI",
  "PDI",
  "ST",
  "PVCG",
  "CON",
  "DI",
  "AC",
  "PE",
  "CU",
];

// Legend toggles (persist across re-renders)
const filterState = {
  basemapEnabled: true,
  overlay: "none", // style mode: 'none' (asset symbology) | 'risk' | 'consequence' | 'breaks'
  diameterBins: new Set(["≤150", "200–250", "300", "400", "500–600", "≥750", "Unknown"]),
  ageBins: new Set(["<20", "20–50", "50–80", "≥80", "Unknown"]),
  materials: new Set([...MATERIAL_ORDER, "Other", "Unknown"]),
};

const riskModel = new RiskConsequenceModel({ currentYear: CURRENT_YEAR });

async function loadRoadProximity() {
  // Expected format: { buffer_m: number, byMain: [{globalid, functional_class, uplift_lof, min_dist_m, source_ctp_class}, ...] }
  try {
    const res = await fetch(roadProximityUrl, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    const data = await res.json();
    const rows = Array.isArray(data?.byMain) ? data.byMain : [];
    const map = new Map();

    for (const r of rows) {
      const gid = (r?.globalid ?? "").toString().trim();
      if (!gid) continue;
      const functionalClass = (r?.functional_class ?? "").toString().trim();
      const upliftLof = Number((r?.uplift_lof ?? "").toString().trim());
      const minDistM = Number((r?.min_dist_m ?? "").toString().trim());
      const sourceCtpClass = (r?.source_ctp_class ?? "").toString().trim();

      if (!functionalClass) continue;
      if (!Number.isFinite(upliftLof) || upliftLof <= 0) continue;

      map.set(gid, {
        functionalClass,
        upliftLof,
        minDistM: Number.isFinite(minDistM) ? minDistM : null,
        sourceCtpClass: sourceCtpClass || null,
      });
    }

    roadExposureByGlobalId = map;
    const bm = Number((data?.buffer_m ?? "").toString().trim());
    roadExposureBufferM = Number.isFinite(bm) ? bm : null;
  } catch (err) {
    // Non-fatal: roads-based risk modifier is optional.
    roadExposureByGlobalId = new Map();
    roadExposureBufferM = null;
    console.warn("Road proximity data not loaded:", err);
  }
}

function isRoadUpliftEligible({ materialCode, ageYears }) {
  const mat = (materialCode ?? "").toString().trim().toUpperCase();
  if (ROAD_AFFECTED_MATERIALS.has(mat)) return true;
  if (mat === "PVC" && typeof ageYears === "number" && Number.isFinite(ageYears)) {
    return ageYears >= OLD_PVC_AGE_YEARS;
  }
  return false;
}

function applyMajorRoadAdjustment(scored, derived) {
  if (!scored || typeof scored !== "object") return scored;
  if (!roadExposureByGlobalId?.size) return scored;
  const gid = (derived?.globalid ?? "").toString().trim();
  if (!gid) return scored;
  const exp = roadExposureByGlobalId.get(gid);
  if (!exp || typeof exp !== "object") return scored;
  if (!isRoadUpliftEligible({ materialCode: derived?.matCode, ageYears: derived?.ageYears })) {
    return scored;
  }

  const uplift = Number(exp.upliftLof);
  if (!Number.isFinite(uplift) || uplift <= 0) return scored;

  const basePofFloat =
    typeof scored.pofFloat === "number" && Number.isFinite(scored.pofFloat)
      ? scored.pofFloat
      : Number(scored.pof ?? 2);
  const basePofLevel = clamp(Number(scored.pof ?? 2), 1, 4);

  const bumpedPofFloat = basePofFloat + uplift;
  const bumpedPofLevel = riskModel.scoreFromFloat01to4(bumpedPofFloat) ?? basePofLevel;

  const cof = clamp(Number(scored.cof ?? 2), 1, 4);
  const riskBin = riskModel.riskBinFromScores(bumpedPofLevel, cof);
  const source = `${(scored.source ?? "").toString()}+roads`;

  return {
    ...scored,
    pof: bumpedPofLevel,
    pofFloat: bumpedPofFloat,
    riskBin,
    source,
    _roadFunctionalClass: (exp.functionalClass ?? "").toString(),
    _roadUpliftLof: uplift,
    _roadMinDistM: Number.isFinite(exp.minDistM) ? exp.minDistM : null,
    _pofBaseLevel: basePofLevel,
    _pofBaseFloat: basePofFloat,
    _roadSourceCtpClass: exp.sourceCtpClass ?? null,
  };
}

async function loadBreakDensity() {
  // Expected format: { byZone: [{p_zone, breaks_per_km, ...}, ...] }
  try {
    const res = await fetch(breakDensityUrl, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    const data = await res.json();
    const rows = Array.isArray(data?.byZone) ? data.byZone : [];

    const map = new Map();
    const densities = [];
    for (const r of rows) {
      const zone = (r?.p_zone ?? "").toString().trim() || "(unknown)";
      const v = Number((r?.breaks_per_km ?? "").toString().trim());
      if (Number.isFinite(v)) {
        map.set(zone, v);
        densities.push(v);
      }
    }

    breakDensityByZone = map;

    // Build a stable 4-bin quantile scale (1..4). If all densities are identical,
    // quantiles will repeat; that's ok.
    if (densities.length > 0) {
      breakDensityScale = d3.scaleQuantile().domain(densities).range([1, 2, 3, 4]);
      const qs = breakDensityScale.quantiles();
      const fmt = (n) => {
        if (!Number.isFinite(n)) return "?";
        if (n === 0) return "0";
        const abs = Math.abs(n);
        const digits = abs >= 10 ? 1 : abs >= 1 ? 2 : 3;
        return Number(n).toFixed(digits);
      };
      const labels = [
        `≤ ${fmt(qs[0])}`,
        `${fmt(qs[0])}–${fmt(qs[1])}`,
        `${fmt(qs[1])}–${fmt(qs[2])}`,
        `> ${fmt(qs[2])}`,
      ];
      breakDensityLegend = { labels, palette: BREAK_DENSITY_PALETTE, quantiles: qs };
    } else {
      breakDensityScale = null;
      breakDensityLegend = null;
    }
  } catch (err) {
    // Non-fatal: break-density overlay is optional.
    breakDensityByZone = new Map();
    breakDensityScale = null;
    breakDensityLegend = null;
    console.warn("Break density data not loaded:", err);
  }
}

async function loadRiskOverridesCsv() {
  // Expected columns: material, diam, year, LoF, CoF, RiskClass, family
  try {
    const res = await fetch(riskCsvUrl, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
    const text = await res.text();
    const rows = d3.csvParse(text);
    const map = new Map();

    const toNum = (v) => {
      const n = Number((v ?? "").toString().trim());
      return Number.isFinite(n) ? n : null;
    };

    for (const r of rows) {
      const materialRaw = (r.material ?? "").toString().trim().toUpperCase();
      const diamRaw = (r.diam ?? "").toString().trim();
      const yearRaw = (r.year ?? "").toString().trim();
      if (!materialRaw || !diamRaw || !yearRaw) continue;

      const key = `${materialRaw}|${diamRaw}|${yearRaw}`;
      map.set(key, {
        LoF: toNum(r.LoF),
        CoF: toNum(r.CoF),
        RiskClass: (r.RiskClass ?? "").toString().trim(),
        family: (r.family ?? "").toString().trim(),
      });
    }

    riskModel.setCombinationOverrides(map);
    return map.size;
  } catch (e) {
    // If the CSV isn't present/valid, keep doc-based scoring.
    console.warn("Risk CSV not loaded; using doc-based heuristic.", e);
    riskModel.setCombinationOverrides(null);
    return 0;
  }
}

function lineWidthForLevel(level, k) {
  // Used for Risk/Consequence styling modes.
  const base = 1.4 + (clamp(level, 1, 4) - 1) * 1.0;
  const boost = Math.max(1.0, Math.min(1.6, 1.0 + 0.25 * Math.log2(k + 1)));
  return base * boost;
}

const MATERIAL_COLORS = new Map(
  MATERIAL_ORDER.map((m, i) => [m, d3.schemeTableau10[i % 10]])
);

function normalizeMaterial(raw) {
  const s = (raw ?? "").toString().trim().toUpperCase();
  if (!s) return "Unknown";
  return s;
}

function materialLabel(code, labels) {
  if (!code) return "Unknown";
  const key = code.toString().trim().toUpperCase();
  const label = labels?.[key];
  return label ?? key;
}

function parseDiameterMm(raw) {
  const n = Number((raw ?? "").toString().trim());
  if (!Number.isFinite(n) || n <= 0) return null;
  return n;
}

function parseInstallYear(raw) {
  const s = (raw ?? "").toString();
  const m = s.match(/\b(18|19|20)\d{2}\b/);
  if (!m) return null;
  const y = Number(m[0]);
  if (!Number.isFinite(y) || y < 1800 || y > CURRENT_YEAR) return null;
  return y;
}

function diameterBin(diamMm) {
  if (diamMm == null) return "Unknown";
  if (diamMm <= 150) return "≤150";
  if (diamMm <= 250) return "200–250";
  if (diamMm <= 300) return "300";
  if (diamMm <= 400) return "400";
  if (diamMm <= 600) return "500–600";
  return "≥750";
}

function materialGroup(matCode) {
  if (!matCode || matCode === "Unknown") return "Unknown";
  return MATERIAL_COLORS.has(matCode) ? matCode : "Other";
}

function ageYears(installYear) {
  if (installYear == null) return null;
  const a = CURRENT_YEAR - installYear;
  return a >= 0 ? a : null;
}

function ageBin(age) {
  if (age == null) return "Unknown";
  if (age < 20) return "<20";
  if (age < 50) return "20–50";
  if (age < 80) return "50–80";
  return "≥80";
}

function dashForAgeBin(bin) {
  // NOTE: The paths use `vector-effect: non-scaling-stroke`, which also prevents
  // stroke dash patterns from scaling with zoom transforms. Therefore we should
  // NOT apply any 1/k scaling here; doing so makes dashes look solid when zoomed in.
  const dash = (a, b) => `${a},${b}`;
  const dashDot = (a, b, c, d) => `${a},${b},${c},${d}`;

  switch (bin) {
    case "<20":
      return null; // solid
    case "20–50":
      return dash(10, 6); // dashed
    case "50–80":
      // Use a very short dash with round linecaps to read as dots.
      return dash(0.8, 6);
    case "≥80":
      // Dash-dot: long dash, gap, dot, gap
      return dashDot(10, 6, 0.8, 6);
    default:
      return dash(2, 10); // sparse dashes for unknown
  }
}

function colorForMaterial(mat) {
  if (MATERIAL_COLORS.has(mat)) return MATERIAL_COLORS.get(mat);
  if (mat === "Unknown") return "#6b7280";
  return "#9ca3af";
}

function baseStrokeWidthForDiameter(diamMm) {
  if (diamMm == null) return 0.8;
  if (diamMm <= 150) return 0.8;
  if (diamMm <= 250) return 1.2;
  if (diamMm <= 300) return 1.6;
  if (diamMm <= 400) return 2.2;
  if (diamMm <= 600) return 3.0;
  return 4.0;
}

function strokeWidthPx(diamMm, k) {
  const base = baseStrokeWidthForDiameter(diamMm);
  // Make differences visible at low zoom without exploding at high zoom.
  const boost = Math.max(0.9, Math.min(1.7, 0.9 + 0.35 * Math.log2(k + 1)));
  return base * boost;
}

function minDiameterForZoomK(k) {
  // Level-of-detail filtering to reduce clutter when zoomed out.
  if (k < 1.5) return 400;
  if (k < 4) return 250;
  if (k < 8) return 150;
  return 0;
}

function renderLegend(labels, onToggle) {
  function makeCheckbox({
    listEl,
    label,
    checked,
    kind,
    value,
    swatchEl,
  }) {
    const li = document.createElement("li");
    const key = document.createElement("div");
    key.className = "key";

    const input = document.createElement("input");
    input.type = "checkbox";
    input.checked = !!checked;
    input.dataset.kind = kind;
    if (value != null) input.dataset.value = value;
    input.addEventListener("change", () => onToggle?.(kind, value, input.checked));

    key.appendChild(input);
    if (swatchEl) key.appendChild(swatchEl);
    li.appendChild(key);
    li.appendChild(document.createTextNode(label));
    listEl.appendChild(li);
  }

  function makeKeyItem({ listEl, label, color }) {
    const li = document.createElement("li");
    const key = document.createElement("div");
    key.className = "key";
    const sw = document.createElement("div");
    sw.className = "swatch";
    sw.style.borderTopWidth = "4px";
    sw.style.borderTopColor = color;
    key.appendChild(sw);
    li.appendChild(key);
    li.appendChild(document.createTextNode(label));
    listEl.appendChild(li);
  }

  if (legendOverlayEl) {
    legendOverlayEl.innerHTML = "";
    const swRisk = document.createElement("div");
    swRisk.className = "swatch";
    swRisk.style.borderTopWidth = "4px";
    swRisk.style.borderTopColor = riskModel.riskPalette()[3];
    makeCheckbox({
      listEl: legendOverlayEl,
      label: "Risk",
      checked: filterState.overlay === "risk",
      kind: "overlay",
      value: "risk",
      swatchEl: swRisk,
    });

    const swCof = document.createElement("div");
    swCof.className = "swatch";
    swCof.style.borderTopWidth = "4px";
    swCof.style.borderTopColor = riskModel.consequencePalette()[3];
    makeCheckbox({
      listEl: legendOverlayEl,
      label: "Consequence",
      checked: filterState.overlay === "consequence",
      kind: "overlay",
      value: "consequence",
      swatchEl: swCof,
    });

    if (breakDensityLegend) {
      const swBreaks = document.createElement("div");
      swBreaks.className = "swatch";
      swBreaks.style.borderTopWidth = "4px";
      swBreaks.style.borderTopColor = breakDensityLegend.palette[3];
      makeCheckbox({
        listEl: legendOverlayEl,
        label: "Break density",
        checked: filterState.overlay === "breaks",
        kind: "overlay",
        value: "breaks",
        swatchEl: swBreaks,
      });
    }
  }

  if (legendOverlayKeyTitleEl) {
    const showKey =
      filterState.overlay !== "none" &&
      !(filterState.overlay === "breaks" && !breakDensityLegend);
    legendOverlayKeyTitleEl.style.display = showKey ? "block" : "none";
  }

  if (legendOverlayKeyEl) {
    legendOverlayKeyEl.innerHTML = "";
    if (filterState.overlay !== "none") {
      if (filterState.overlay === "breaks") {
        if (breakDensityLegend) {
          for (let i = 0; i < 4; i++) {
            makeKeyItem({
              listEl: legendOverlayKeyEl,
              label: breakDensityLegend.labels[i],
              color: breakDensityLegend.palette[i],
            });
          }
        }
      } else {
        const palette =
          filterState.overlay === "risk"
            ? riskModel.riskPalette()
            : riskModel.consequencePalette();
        for (let i = 0; i < 4; i++) {
          makeKeyItem({
            listEl: legendOverlayKeyEl,
            label: riskModel.riskLabels[i],
            color: palette[i],
          });
        }
      }
    }
  }

  if (legendBasemapEl) {
    legendBasemapEl.innerHTML = "";
    const sw = document.createElement("div");
    sw.className = "swatch";
    sw.style.borderTopWidth = "3px";
    sw.style.borderTopColor = "#9ca3af";
    makeCheckbox({
      listEl: legendBasemapEl,
      label: "OpenStreetMap",
      checked: filterState.basemapEnabled,
      kind: "basemap",
      value: "osm",
      swatchEl: sw,
    });
  }

  if (legendDiameterEl) {
    legendDiameterEl.innerHTML = "";
    const diaItems = [
      { label: "≤150", w: 0.8 },
      { label: "200–250", w: 1.2 },
      { label: "300", w: 1.6 },
      { label: "400", w: 2.2 },
      { label: "500–600", w: 3.0 },
      { label: "≥750", w: 4.0 },
      { label: "Unknown", w: 0.8 },
    ];
    for (const it of diaItems) {
      const sw = document.createElement("div");
      sw.className = "swatch";
      sw.style.borderTopWidth = `${it.w}px`;
      sw.style.borderTopColor = "#111827";
      makeCheckbox({
        listEl: legendDiameterEl,
        label: it.label,
        checked: filterState.diameterBins.has(it.label),
        kind: "diameter",
        value: it.label,
        swatchEl: sw,
      });
    }
  }

  if (legendAgeEl) {
    legendAgeEl.innerHTML = "";
    const ageItems = [
      { label: "<20 years", bin: "<20" },
      { label: "20–50 years", bin: "20–50" },
      { label: "50–80 years", bin: "50–80" },
      { label: "≥80 years", bin: "≥80" },
      { label: "Unknown", bin: "Unknown" },
    ];
    for (const it of ageItems) {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", "44");
      svg.setAttribute("height", "12");
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", "2");
      line.setAttribute("x2", "42");
      line.setAttribute("y1", "6");
      line.setAttribute("y2", "6");
      line.setAttribute("stroke", "#111827");
      line.setAttribute("stroke-width", "3");
      line.setAttribute("stroke-linecap", "round");
      const dash = dashForAgeBin(it.bin);
      if (dash) line.setAttribute("stroke-dasharray", dash);
      svg.appendChild(line);
      makeCheckbox({
        listEl: legendAgeEl,
        label: it.label,
        checked: filterState.ageBins.has(it.bin),
        kind: "age",
        value: it.bin,
        swatchEl: svg,
      });
    }
  }

  if (legendMaterialEl) {
    legendMaterialEl.innerHTML = "";
    const mats = [...MATERIAL_ORDER, "Other", "Unknown"];
    for (const m of mats) {
      const sw = document.createElement("div");
      sw.className = "swatch";
      sw.style.borderTopWidth = "3px";
      sw.style.borderTopColor =
        m === "Other" ? "#9ca3af" : m === "Unknown" ? "#6b7280" : colorForMaterial(m);
      const label =
        m === "Other" || m === "Unknown" ? m : materialLabel(m, labels);
      makeCheckbox({
        listEl: legendMaterialEl,
        label,
        checked: filterState.materials.has(m),
        kind: "material",
        value: m,
        swatchEl: sw,
      });
    }
  }
}

function showError(err) {
  if (statusEl) statusEl.remove();
  const div = document.createElement("div");
  div.className = "error";
  div.textContent = `Failed to load/render GeoJSON.\n\n${err?.message ?? err}`;
  container.appendChild(div);
}

function clearStatus() {
  if (statusEl) statusEl.remove();
}

function createSvg(width, height) {
  const svg = d3
    .select(container)
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", `0 0 ${width} ${height}`)
    .attr("preserveAspectRatio", "xMidYMid meet");

  return svg;
}

function ensureTileLayer() {
  if (!tilesEl) return null;
  let layer = tilesEl.querySelector(".tile-layer");
  if (!layer) {
    layer = document.createElement("div");
    layer.className = "tile-layer";
    tilesEl.appendChild(layer);
  }
  return layer;
}

function summarizeProperties(properties, labels) {
  if (!properties || typeof properties !== "object") return "(no properties)";

  const diamMm = parseDiameterMm(properties.diam);
  const material = normalizeMaterial(properties.material);
  const materialName = materialLabel(material, labels);
  const iy = parseInstallYear(properties.year);
  const age = ageYears(iy);

  const matCode = normalizeMaterial(properties.material);
  const statusInd = (properties.status_ind ?? "").toString();
  const lengthM = Number.isFinite(Number(properties.length)) ? Number(properties.length) : null;
  const ageYearsValue = age;

  const materialRaw = (properties.material ?? "").toString().trim();
  const diamRaw = (properties.diam ?? "").toString().trim();
  const yearRaw = (properties.year ?? "").toString().trim();

  const scored = riskModel.compute({
    materialCode: matCode,
    diamMm,
    installYear: iy,
    statusInd,
    lengthM,
    comboKeyParts: { materialRaw, diamRaw, yearRaw },
  });
  const gid = (properties.globalid ?? "").toString().trim();
  const derivedForRoads = { globalid: gid, matCode, ageYears: ageYearsValue };
  const adj = applyMajorRoadAdjustment(scored, derivedForRoads);
  const { pof, cof, riskBin: rbin, riskClass, family, source } = adj;

  const lines = [];
  lines.push(`diam: ${diamMm ?? "Unknown"}${diamMm != null ? " mm" : ""}`);
  lines.push(`material: ${materialName}`);
  lines.push(`year: ${iy ?? "Unknown"}`);
  lines.push(`age: ${age ?? "Unknown"}${age != null ? " yrs" : ""}`);
  lines.push(`risk: ${riskModel.riskLabels[rbin - 1]} (PoF ${pof} × CoF ${cof})`);
  if (riskClass) lines.push(`risk class (csv): ${riskClass}`);
  if (family) lines.push(`risk family (csv): ${family}`);
  lines.push(`consequence: ${riskModel.riskLabels[cof - 1]} (${cof})`);
  lines.push(`risk source: ${source}`);

  if (Number.isFinite(adj?._roadUpliftLof)) {
    const bm = Number.isFinite(roadExposureBufferM) ? roadExposureBufferM : null;
    const bmTxt = bm != null ? ` (≤${bm}m)` : "";
    const distTxt = Number.isFinite(adj?._roadMinDistM)
      ? ` (min ${Number(adj._roadMinDistM).toFixed(1)} m)`
      : "";
    const cls = (adj?._roadFunctionalClass ?? "").toString().trim();
    const ctp = (adj?._roadSourceCtpClass ?? "").toString().trim();
    const clsTxt = cls ? ` ${cls}` : "";
    const ctpTxt = ctp ? ` [${ctp}]` : "";

    const baseLevel = Number.isFinite(adj?._pofBaseLevel) ? adj._pofBaseLevel : null;
    const bumpTxt = baseLevel != null && baseLevel !== pof ? ` (LoF ${baseLevel}→${pof}, +${adj._roadUpliftLof})` : "";
    lines.push(`major road exposure${bmTxt}: yes${clsTxt}${ctpTxt}${distTxt}${bumpTxt}`);
  }

  const zone = (properties.p_zone ?? "").toString().trim();
  if (zone && breakDensityByZone?.size) {
    const v = breakDensityByZone.get(zone);
    if (Number.isFinite(v)) {
      lines.push(`breaks/km (zone): ${Number(v).toFixed(3)}`);
    }
  }

  // Add a couple extra fields if present.
  for (const k of ["status_ind", "p_zone", "length"]) {
    if (properties[k] != null && properties[k] !== "") {
      lines.push(`${k}: ${properties[k]}`);
    }
  }

  return lines.join("\n");
}

function setTooltip(text, x, y) {
  if (!tooltipEl) return;
  if (!text) {
    tooltipEl.style.transform = "translate(-9999px, -9999px)";
    tooltipEl.setAttribute("aria-hidden", "true");
    return;
  }

  tooltipEl.textContent = text;
  tooltipEl.setAttribute("aria-hidden", "false");
  tooltipEl.style.transform = `translate(${x + 12}px, ${y + 12}px)`;
}

function render(geojson, labels) {
  container.querySelectorAll("svg").forEach((n) => n.remove());

  const tileLayer = ensureTileLayer();
  if (tileLayer) tileLayer.innerHTML = "";

  const { width, height } = container.getBoundingClientRect();
  const w = Math.max(320, Math.floor(width));
  const h = Math.max(240, Math.floor(height));

  const svg = createSvg(w, h);

  const projection = d3.geoMercator();
  const path = d3.geoPath(projection);

  // Fit projection to data.
  projection.fitSize([w, h], geojson);

  // On first render, restore URL state (zoom + filters). Subsequent re-renders
  // (e.g., resize) should preserve the in-memory state.
  if (!urlState.initialized) {
    readUrlStateIntoFilterState();
    urlState.initialized = true;
  }

  let currentTransform = urlState.transform ?? d3.zoomIdentity;

  function applyBasemapVisibility() {
    if (!tilesEl) return;
    tilesEl.style.display = filterState.basemapEnabled ? "block" : "none";
  }

  function onToggle(kind, value, checked) {
    if (kind === "overlay") {
      // Mutually exclusive overlays.
      if (checked) filterState.overlay = value;
      else if (filterState.overlay === value) filterState.overlay = "none";

      renderLegend(labels, onToggle);
      updateSymbology(currentTransform.k);
      scheduleUrlWrite(currentTransform);
      return;
    }

    if (kind === "basemap") {
      filterState.basemapEnabled = checked;
      applyBasemapVisibility();
      updateTiles(currentTransform);
      scheduleUrlWrite(currentTransform);
      return;
    }

    if (kind === "diameter") {
      if (checked) filterState.diameterBins.add(value);
      else filterState.diameterBins.delete(value);
    }

    if (kind === "age") {
      if (checked) filterState.ageBins.add(value);
      else filterState.ageBins.delete(value);
    }

    if (kind === "material") {
      if (checked) filterState.materials.add(value);
      else filterState.materials.delete(value);
    }

    updateSymbology(currentTransform.k);
    scheduleUrlWrite(currentTransform);
  }

  renderLegend(labels, onToggle);
  applyBasemapVisibility();

  const g = svg.append("g").attr("class", "layer main-layer");

  const zoom = d3
    .zoom()
    .scaleExtent([1, 20])
    .on("zoom", (event) => {
      currentTransform = event.transform;
      urlState.transform = currentTransform;
      g.attr("transform", event.transform);
      updateSymbology(event.transform.k);
      updateTiles(event.transform);
      scheduleUrlWrite(event.transform);
    });

  svg.call(zoom);

  function featureId(d, i) {
    return d?.id ?? d?.properties?.OBJECTID ?? d?.properties?.ObjectId ?? i;
  }

  const features =
    geojson.type === "FeatureCollection" ? geojson.features : [geojson];

  // Compute derived values once for faster styling + filtering.
  for (const f of features) {
    const props = f?.properties ?? {};
    const diamMm = parseDiameterMm(props.diam);
    const diamBin = diameterBin(diamMm);
    const matCode = normalizeMaterial(props.material);
    const matGroup = materialGroup(matCode);
    const iy = parseInstallYear(props.year);
    const a = ageYears(iy);
    const aBin = ageBin(a);

    const statusInd = (props.status_ind ?? "").toString();
    const lengthN = Number((props.length ?? "").toString().trim());
    const lengthM = Number.isFinite(lengthN) ? lengthN : null;

    const pZone = (props.p_zone ?? "").toString().trim() || "(unknown)";
    const globalid = (props.globalid ?? "").toString().trim();

    const derived = {
      diamMm,
      diamBin,
      matCode,
      matGroup,
      installYear: iy,
      ageYears: a,
      ageBin: aBin,
      statusInd,
      lengthM,
      pZone,
      globalid,
    };

    const materialRaw = (props.material ?? "").toString().trim();
    const diamRaw = (props.diam ?? "").toString().trim();
    const yearRaw = (props.year ?? "").toString().trim();

    const scored = riskModel.compute({
      materialCode: derived.matCode,
      diamMm: derived.diamMm,
      installYear: derived.installYear,
      statusInd: derived.statusInd,
      lengthM: derived.lengthM,
      comboKeyParts: { materialRaw, diamRaw, yearRaw },
    });
    const adj = applyMajorRoadAdjustment(scored, derived);
    const { pof, cof, riskBin, riskClass, family, source } = adj;
    derived.pof = pof;
    derived.cof = cof;
    derived.riskBin = riskBin;
    derived.riskClass = riskClass;
    derived.riskFamily = family;
    derived.riskSource = source;
    derived.roadFunctionalClass = (adj?._roadFunctionalClass ?? "").toString().trim() || null;
    derived.roadUpliftLof = Number.isFinite(adj?._roadUpliftLof) ? adj._roadUpliftLof : null;
    derived.roadMinDistM = Number.isFinite(adj?._roadMinDistM) ? adj._roadMinDistM : null;

    const breaksPerKm = breakDensityByZone?.get(pZone);
    derived.breaksPerKm = Number.isFinite(breaksPerKm) ? breaksPerKm : null;
    if (derived.breaksPerKm != null && breakDensityScale) {
      derived.breaksBin = breakDensityScale(derived.breaksPerKm);
    } else {
      derived.breaksBin = null;
    }
    f._derived = derived;
  }

  const paths = g
    .selectAll("path")
    .data(features)
    .join("path")
    .attr("class", "feature")
    .attr("d", path)
    .on("mouseenter", function () {
      d3.select(this).classed("is-hover", true);
    })
    .on("mousemove", function (event, d) {
      const [mx, my] = d3.pointer(event, container);
      const text = summarizeProperties(d?.properties, labels);
      setTooltip(text, mx, my);
    })
    .on("mouseleave", function () {
      d3.select(this).classed("is-hover", false);
      setTooltip(null);
    })
    .on("click", function (event, d) {
      event.preventDefault();
      event.stopPropagation();
    });

  function updateSymbology(k) {
    const minDiam = minDiameterForZoomK(k);

    const styleMode = filterState.overlay ?? "none";

    paths
      .attr("stroke-linecap", "round")
      .attr("stroke", (d) => {
        const derived = d?._derived;
        if (styleMode === "risk") {
          const bin = clamp(Number(derived?.riskBin ?? 2), 1, 4);
          return riskModel.riskPalette()[bin - 1];
        }
        if (styleMode === "consequence") {
          const cof = clamp(Number(derived?.cof ?? 2), 1, 4);
          return riskModel.consequencePalette()[cof - 1];
        }
        if (styleMode === "breaks") {
          const bin = Number(derived?.breaksBin);
          if (Number.isFinite(bin)) {
            return BREAK_DENSITY_PALETTE[clamp(bin, 1, 4) - 1];
          }
          return "#9ca3af";
        }

        const matCode = derived?.matCode ?? normalizeMaterial(d?.properties?.material);
        if (matCode !== "Unknown" && !MATERIAL_COLORS.has(matCode)) return "#9ca3af";
        return colorForMaterial(matCode);
      })
      .attr("stroke-dasharray", (d) => {
        if (styleMode === "risk" || styleMode === "consequence" || styleMode === "breaks") return null;
        const bin = d?._derived?.ageBin ?? ageBin(ageYears(parseInstallYear(d?.properties?.year)));
        const dash = dashForAgeBin(bin);
        return dash ?? null;
      })
      .attr("stroke-width", (d) => {
        const derived = d?._derived;
        if (styleMode === "risk") {
          const bin = clamp(Number(derived?.riskBin ?? 2), 1, 4);
          return lineWidthForLevel(bin, k);
        }
        if (styleMode === "consequence") {
          const cof = clamp(Number(derived?.cof ?? 2), 1, 4);
          return lineWidthForLevel(cof, k);
        }
        if (styleMode === "breaks") {
          const diamMm = derived?.diamMm ?? parseDiameterMm(d?.properties?.diam);
          return strokeWidthPx(diamMm, k);
        }
        const diamMm = derived?.diamMm ?? parseDiameterMm(d?.properties?.diam);
        return strokeWidthPx(diamMm, k);
      })
      .style("display", (d) => {
        const derived = d?._derived;
        const diamMm = derived?.diamMm ?? parseDiameterMm(d?.properties?.diam);
        const diamBin = derived?.diamBin ?? diameterBin(diamMm);
        const matGroup = derived?.matGroup ?? materialGroup(normalizeMaterial(d?.properties?.material));
        const aBin = derived?.ageBin ?? ageBin(ageYears(parseInstallYear(d?.properties?.year)));

        if (!filterState.diameterBins.has(diamBin)) return "none";
        if (!filterState.materials.has(matGroup)) return "none";
        if (!filterState.ageBins.has(aBin)) return "none";

        if (minDiam <= 0) return null;
        if (diamMm == null) return "none";
        return diamMm >= minDiam ? null : "none";
      });
  }

  // Raster tiles: compute visible tiles for the current zoom transform.
  function updateTiles(transform) {
    if (!filterState.basemapEnabled) return;
    if (!tileLayer) return;

    // Apply the same transform to tiles so panning/zooming stays perfectly in sync.
    tileLayer.style.transform = `translate(${transform.x}px, ${transform.y}px) scale(${transform.k})`;

    // Derive a tile zoom level based on mercator scale.
    const worldPx = projection.scale() * 2 * Math.PI;
    const z0 = Math.log2(worldPx / 256);
    const z = clamp(Math.round(z0 + Math.log2(transform.k)), 0, TILE_MAX_Z);

    // Visible extent in *base* (untransformed) pixels.
    const x0 = (0 - transform.x) / transform.k;
    const y0 = (0 - transform.y) / transform.k;
    const x1 = (w - transform.x) / transform.k;
    const y1 = (h - transform.y) / transform.k;

    const p0 = projection.invert([x0, y0]);
    const p1 = projection.invert([x1, y1]);
    if (!p0 || !p1) return;

    const lonMin = Math.min(p0[0], p1[0]);
    const lonMax = Math.max(p0[0], p1[0]);
    const latMin = Math.min(p0[1], p1[1]);
    const latMax = Math.max(p0[1], p1[1]);

    const n = 2 ** z;
    let xMin = clamp(lonToTileX(lonMin, z) - 1, 0, n - 1);
    let xMax = clamp(lonToTileX(lonMax, z) + 1, 0, n - 1);
    let yMin = clamp(latToTileY(latMax, z) - 1, 0, n - 1); // top
    let yMax = clamp(latToTileY(latMin, z) + 1, 0, n - 1); // bottom

    // Guard against pathological inversions.
    if (xMax < xMin || yMax < yMin) return;

    const tiles = [];
    for (let ty = yMin; ty <= yMax; ty++) {
      for (let tx = xMin; tx <= xMax; tx++) {
        tiles.push({ z, x: tx, y: ty, key: `${z}/${tx}/${ty}` });
      }
    }

    const join = d3
      .select(tileLayer)
      .selectAll("img")
      .data(tiles, (d) => d.key);

    join.exit().remove();

    join
      .enter()
      .append("img")
      .attr("alt", "")
      .attr("loading", "lazy")
      .attr("referrerpolicy", "no-referrer")
      .attr("src", (d) => tileUrl(d.z, d.x, d.y))
      .merge(join)
      .each(function (d) {
        // Project tile bounds to our base pixel coordinate space.
        const lonL = tileXToLon(d.x, d.z);
        const lonR = tileXToLon(d.x + 1, d.z);
        const latT = tileYToLat(d.y, d.z);
        const latB = tileYToLat(d.y + 1, d.z);

        const pTL = projection([lonL, latT]);
        const pBR = projection([lonR, latB]);
        if (!pTL || !pBR) return;

        const left = pTL[0];
        const top = pTL[1];
        const widthPx = pBR[0] - pTL[0];
        const heightPx = pBR[1] - pTL[1];

        const img = this;
        img.style.left = `${left}px`;
        img.style.top = `${top}px`;
        img.style.width = `${widthPx}px`;
        img.style.height = `${heightPx}px`;
      });
  }

  // Apply initial/restore transform (triggers zoom handler, symbology, tiles).
  svg.call(zoom.transform, currentTransform);

  // Ensure URL reflects the current state even if the page loads with defaults.
  scheduleUrlWrite(currentTransform);

  svg.on("click", () => {
    // no-op (selection/inspector removed)
  });
}

async function main() {
  try {
    initLegendToggle();
    await Promise.all([loadRiskOverridesCsv(), loadBreakDensity(), loadRoadProximity()]);
    const [geojson, labels] = await Promise.all([
      d3.json(geojsonUrl),
      d3.json(materialLabelsUrl).catch(() => ({})),
    ]);
    clearStatus();
    render(geojson, labels);

    // Re-render on resize to keep it fitting the viewport.
    let resizeRaf = null;
    window.addEventListener("resize", () => {
      if (resizeRaf) cancelAnimationFrame(resizeRaf);
      resizeRaf = requestAnimationFrame(() => render(geojson, labels));
    });
  } catch (err) {
    showError(err);
  }
}

main();
